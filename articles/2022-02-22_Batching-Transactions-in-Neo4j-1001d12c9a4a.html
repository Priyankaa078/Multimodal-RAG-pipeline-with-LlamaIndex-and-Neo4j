<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Batching Transactions in Neo4j</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Batching Transactions in Neo4j</h1>
</header>
<section data-field="subtitle" class="p-summary">
Learn the difference between APOC and native Cypher approach to batching transactions
</section>
<section data-field="body" class="e-content">
<section name="134e" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="8865" id="8865" class="graf graf--h3 graf--leading graf--title">Batching Transactions in Neo4j</h3><h4 name="4ad9" id="4ad9" class="graf graf--h4 graf-after--h3 graf--subtitle">Learn the difference between APOC and native Cypher approach to batching transactions</h4><figure name="6da0" id="6da0" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="0*RadpkSkkasxaTVFk" data-width="5472" data-height="3648" data-unsplash-photo-id="krhseyzjrYk" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*RadpkSkkasxaTVFk"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@hdbernd?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com/@hdbernd?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-creator noopener" target="_blank">Bernd Dittrich</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-source noopener" target="_blank">Unsplash</a></figcaption></figure><p name="49c1" id="49c1" class="graf graf--p graf-after--figure">When dealing with massive graphs and more extensive updates in Neo4j, you will likely run out of heap memory if you don’t resort to batching transactions. While you could use your favorite scripting language to batch transactions, you can also split a single Cypher query into multiple transactions directly in Cypher or with the help of the APOC library.<br>This post aims to demonstrate the latter, meaning we will only look at how to split a single Cypher query into multiple transactions.</p><p name="cc9b" id="cc9b" class="graf graf--p graf-after--p">We will be using the <a href="https://sandbox.neo4j.com/?usecase=icij-paradise-papers" data-href="https://sandbox.neo4j.com/?usecase=icij-paradise-papers" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">ICIJ Paradise Papers dataset</a>, made available by International Consortium of Investigative Journalists (ICIJ). The ICIJ has a long history of publishing spectacular researches like the Panama, Paradise, and the latest Pandora Papers. If you are interested, you can explore the <a href="https://offshoreleaks.icij.org/" data-href="https://offshoreleaks.icij.org/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">datasets on their website</a>, or download the data (licensed under Open Database License) and explore it with your favorite data mining tool. Luckily for us, the dataset is available as a Neo4j Sandbox project. Neo4j Sandbox is a free cloud instance of Neo4j that comes with a pre-populated database. Click on the <a href="https://sandbox.neo4j.com/?usecase=icij-paradise-papers" data-href="https://sandbox.neo4j.com/?usecase=icij-paradise-papers" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">following link</a> to create your own Sandbox instance of the Paradise Papers dataset.</p><p name="b763" id="b763" class="graf graf--p graf-after--p">While the graph model is a slightly more complex, we will only use the following subset of the graph for our demonstration.</p><figure name="1cde" id="1cde" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*KUfArNy1dHiBDFIRbtfKOQ.png" data-width="1031" data-height="700" src="https://cdn-images-1.medium.com/max/800/1*KUfArNy1dHiBDFIRbtfKOQ.png"><figcaption class="imageCaption">Subset of the Paradise Papers graph. Image by the author.</figcaption></figure><p name="9c33" id="9c33" class="graf graf--p graf-after--figure">We are only interested in officers (green) and entities (orange) and the OFFICER_OF relationships between the two. This is essentially a bi-partite network containing two types of nodes. To analyze bi-partite networks, we often transform them into a monopartite network as the first step of the analysis. In this example, we will use the above bi-partite network and project a monopartite network representing officers, and the relationships between them will define if and how many entities they have in common.</p><figure name="314b" id="314b" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*dnoJJAeSlfyHquNPmkXSgQ.png" data-width="471" data-height="291" src="https://cdn-images-1.medium.com/max/800/1*dnoJJAeSlfyHquNPmkXSgQ.png"><figcaption class="imageCaption">Monopartite projection of officers. Image by the author.</figcaption></figure><p name="731e" id="731e" class="graf graf--p graf-after--figure">This is a straightforward operation in Cypher. We simply match the original pattern and count the occurrences, and optionally store the results as relationships between officers. However, these types of operations are likely to explode in the number of rows.</p><pre name="5a4a" id="5a4a" class="graf graf--pre graf-after--p">MATCH (n:Officer)-[:OFFICER_OF]-&gt;(:Entity)&lt;-[:OFFICER_OF]-(m)</pre><pre name="bab1" id="bab1" class="graf graf--pre graf-after--pre">// avoid duplication<br>WHERE id(n) &lt; id(m)</pre><pre name="f03f" id="f03f" class="graf graf--pre graf-after--pre">// count the number of occurrences per pair of node<br>WITH n,m, count(*) AS common</pre><pre name="3473" id="3473" class="graf graf--pre graf-after--pre">// return the total number of rows<br>RETURN count(*) AS numberOfRows</pre><p name="b125" id="b125" class="graf graf--p graf-after--pre">In our example, we need to create 1.313.187 relationships to project a monopartite network of officers and store the number of common entities as the relationship weight. If two officers have no entities in common, a relationship is not created.</p><p name="d77b" id="d77b" class="graf graf--p graf-after--p">Unfortunately, the Neo4j Sandbox instance has only 1GB of heap memory. Consequently, creating more than a million relationships in a single transaction is likely to run into memory issues. Before we continue, we need to increase the transaction timeout setting. By default, the Sandbox instances have a transaction timeout of 30 seconds, meaning that if a transaction lasts longer than 30 seconds, it will be automatically terminated. We can avoid that by setting the following transaction timeout configuration.</p><pre name="9f6f" id="9f6f" class="graf graf--pre graf-after--p">CALL dbms.setConfigValue(‘dbms.transaction.timeout’,’0&#39;);</pre><p name="403a" id="403a" class="graf graf--p graf-after--pre">For those of you who have some experience with Neo4j and batching, you might be familiar with the <code class="markup--code markup--p-code">apoc.periodic.iterate</code> procedure, which is frequently used to batch transactions.</p><pre name="033e" id="033e" class="graf graf--pre graf-after--p">CALL apoc.periodic.iterate(</pre><pre name="76e0" id="76e0" class="graf graf--pre graf-after--pre">  // first statement<br>  &quot;MATCH (n:Officer)-[:OFFICER_OF]-&gt;()&lt;-[:OFFICER_OF]-(m)<br>   WHERE id(n) &lt; id(m)<br>   WITH n,m, count(*) AS common<br>   RETURN n,m, common&quot;,<br>  // second statement<br>  &quot;MERGE (n)-[c:COMMON_ENTITY_APOC]-&gt;(m)<br>   SET c.count = common&quot;, <br>  // configuration<br>  {batchSize:50000})</pre><p name="01d6" id="01d6" class="graf graf--p graf-after--pre">In the first statement, we provide the data stream to operate on. The data stream can consist of millions of rows. The second statement does the actual update. In our case, it will create a new relationship between a pair of officers and store the count as the relationship weight. By defining the <code class="markup--code markup--p-code">batchSize</code>parameter in the configuration, we describe the number of rows to be committed in a single transaction. For example, by setting the <code class="markup--code markup--p-code">batchSize</code>to 50.000, a transaction will be committed after 50.000 executions of the second statement. In our case, the first statement produces 1.3 million rows, which means that the update will be split into 26 transactions.</p><p name="16dd" id="16dd" class="graf graf--p graf-after--p">In Neo4j 4.4, batching transactions was introduced as a native Cypher feature. To batch transactions using only Cypher, you have to define a <a href="https://neo4j.com/docs/cypher-manual/current/clauses/call-subquery/" data-href="https://neo4j.com/docs/cypher-manual/current/clauses/call-subquery/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">subquery</a> that updates the graph and is followed by the <code class="markup--code markup--p-code">IN TRANSACTIONS OF X ROWS</code> .</p><pre name="87c3" id="87c3" class="graf graf--pre graf-after--p">:auto MATCH (n:Officer)-[:OFFICER_OF]-&gt;()&lt;-[:OFFICER_OF]-(m)<br>WHERE id(n) &lt; id(m)<br>WITH n,m, count(*) AS common<br>CALL {<br> WITH n,m,common<br> MERGE (n)-[c:COMMON_ENTITY_CYPHER]-&gt;(m)<br> SET c.count = common} IN TRANSACTIONS OF 50000 ROWS</pre><p name="8b91" id="8b91" class="graf graf--p graf-after--pre">If you execute the above Cypher statement in Neo4j Browser, you must prepend the <code class="markup--code markup--p-code">:auto</code>command. Otherwise, you can omit it when executing this Cypher query from your favorite scripting language. The logic is identical to the APOC batching. We first define the stream of data (first statement) and then use a subquery (second statement) to batch large updates.</p><h4 name="1e64" id="1e64" class="graf graf--h4 graf-after--p">When to use which?</h4><p name="4d59" id="4d59" class="graf graf--p graf-after--h4">So what’s the difference, and when should you use which?</p><p name="0d7a" id="0d7a" class="graf graf--p graf-after--p">I think the most significant difference is in how they handle errors. First of all, if a single execution within a batch fails, then the whole batch fails, independent of if you are using APOC or Cypher to batch transactions. However, the Cypher variant will not continue with the operation after a single batch has failed and all the previously successfully committed transactions will not be rolled back. So, if the third transaction has failed, the previous two that were successfully committed will not be rolled back.<br>On the contrary, the APOC variant has no problem if an intermediate batch fails and will iterate through all the batches regardless. Furthermore, APOC also has the option to define retries in case of a failing batch, which is something that native Cypher transaction batching lacks.</p><p name="9c65" id="9c65" class="graf graf--p graf-after--p">For example, when you want to update nodes through an external API, I would advise to use the <code class="markup--code markup--p-code">apoc.periodic.iterate</code> with the <code class="markup--code markup--p-code">batchSize</code> value of 1. As external APIs are unpredictable and potentially costly, we want to store all the information we gathered from the API and iterate through all the nodes regardless if some updates failed in between.</p><p name="53cf" id="53cf" class="graf graf--p graf-after--p">Another feature that <code class="markup--code markup--p-code">apoc.periodic.iterate</code>has is the option to run update statements in parallel. We need to ensure that we won’t run into any deadlocks when doing parallel updates. Otherwise, the transaction execution will fail. As a rule of thumb, you can’t use parallel execution when creating relationships because the query might try to create several relationships starting or ending from the same node, which will result in a node deadlock and failed execution. However, when you update a single node property once, you can be confident that you won’t run into any deadlocks. For example, if you wanted to store the node degree as a node property you could use parallel execution.</p><pre name="3206" id="3206" class="graf graf--pre graf-after--p">CALL apoc.periodic.iterate(<br>  &quot;MATCH (o:Officer)<br>   RETURN o&quot;,<br>   &quot;WITH o, size((o)--()) AS degree<br>    SET o.degree = degree&quot;, <br>   {batchSize:10000, parallel: true})</pre><h4 name="47dc" id="47dc" class="graf graf--h4 graf-after--pre">Conclusion</h4><p name="2f57" id="2f57" class="graf graf--p graf-after--h4">All in all, it seems that the <code class="markup--code markup--p-code">apoc.periodic.iterate</code> is the older and more mature brother from the transaction procedure family. As of now, I am more inclined to use the APOC batching instead of native Cypher batching. The only advantage to the Cypher approach I see is if you want to terminate the operation after a single failed batch, otherwise I would still suggest to use APOC.</p><p name="de2e" id="de2e" class="graf graf--p graf-after--p graf--trailing"><em class="markup--em markup--p-em">p.s. If you are interested in graph analysis, I’ve prepared a s</em><a href="https://tbgraph.wordpress.com/2018/02/19/paradise-papers-analysis-with-neo4j/" data-href="https://tbgraph.wordpress.com/2018/02/19/paradise-papers-analysis-with-neo4j/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><em class="markup--em markup--p-em">ample graph analysis of the Paradise Paper dataset back in the day</em></a><em class="markup--em markup--p-em">s</em></p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@bratanic-tomaz" class="p-author h-card">Tomaz Bratanic</a> on <a href="https://medium.com/p/1001d12c9a4a"><time class="dt-published" datetime="2022-02-22T15:36:19.761Z">February 22, 2022</time></a>.</p><p><a href="https://medium.com/@bratanic-tomaz/batching-transactions-in-neo4j-1001d12c9a4a" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on November 5, 2023.</p></footer></article></body></html>