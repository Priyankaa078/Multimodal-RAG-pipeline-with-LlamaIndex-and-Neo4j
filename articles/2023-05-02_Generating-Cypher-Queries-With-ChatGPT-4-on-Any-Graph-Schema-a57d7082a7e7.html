<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Generating Cypher Queries With ChatGPT 4 on Any Graph Schema</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Generating Cypher Queries With ChatGPT 4 on Any Graph Schema</h1>
</header>
<section data-field="subtitle" class="p-summary">
Will we still need to learn query languages in the future?
</section>
<section data-field="body" class="e-content">
<section name="da66" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="b027" id="b027" class="graf graf--h3 graf--leading graf--title">Generating Cypher Queries With ChatGPT 4 on Any Graph Schema</h3><h4 name="6b6e" id="6b6e" class="graf graf--h4 graf-after--h3 graf--subtitle">Will we still need to learn query languages in the future?</h4><figure name="e7f4" id="e7f4" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="0*zq9Gk3zXazj7chwt" data-width="6000" data-height="4000" data-unsplash-photo-id="TVCDj_fFvx8" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*zq9Gk3zXazj7chwt"><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@lhgerona?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com/@lhgerona?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-creator noopener" target="_blank">Lyman Hansel Gerona</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" data-href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" class="markup--anchor markup--figure-anchor" rel="photo-source noopener" target="_blank">Unsplash</a></figcaption></figure><p name="4e59" id="4e59" class="graf graf--p graf-after--figure">Large language models have great potential to translate a natural language into a query language. For example, some people use <a href="https://medium.com/@itsdaniyalm/how-to-convert-text-to-sql-and-natural-language-questions-to-sql-queries-using-gpt3-and-python-44a6bf8529b5" data-href="https://medium.com/@itsdaniyalm/how-to-convert-text-to-sql-and-natural-language-questions-to-sql-queries-using-gpt3-and-python-44a6bf8529b5" class="markup--anchor markup--p-anchor" target="_blank">GPT models to translate text to SQL</a>, while others use <a href="https://www.wisecube.ai/blog/sparql-queries-gpts-and-large-language-models-where-are-we-currently/" data-href="https://www.wisecube.ai/blog/sparql-queries-gpts-and-large-language-models-where-are-we-currently/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">GPT models to construct SPARQL queries</a>. I prefer exploring how to <a href="https://medium.com/neo4j/context-aware-knowledge-graph-chatbot-with-gpt-4-and-neo4j-d3a99e8ae21e" data-href="https://medium.com/neo4j/context-aware-knowledge-graph-chatbot-with-gpt-4-and-neo4j-d3a99e8ae21e" class="markup--anchor markup--p-anchor" target="_blank">translate natural language to Cypher query language</a>.</p><div name="8370" id="8370" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/neo4j/context-aware-knowledge-graph-chatbot-with-gpt-4-and-neo4j-d3a99e8ae21e" data-href="https://medium.com/neo4j/context-aware-knowledge-graph-chatbot-with-gpt-4-and-neo4j-d3a99e8ae21e" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/neo4j/context-aware-knowledge-graph-chatbot-with-gpt-4-and-neo4j-d3a99e8ae21e"><strong class="markup--strong markup--mixtapeEmbed-strong">Context-Aware Knowledge Graph Chatbot With GPT-4 and Neo4j</strong><br><em class="markup--em markup--mixtapeEmbed-em">Learn how to implement a chatbot that bases its answers on the information retrieved from a graph database.</em>medium.com</a><a href="https://medium.com/neo4j/context-aware-knowledge-graph-chatbot-with-gpt-4-and-neo4j-d3a99e8ae21e" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="1b46cf958dcd77270df9dfb08f14dd0e" data-thumbnail-img-id="1*21Rie9n9o92D3km_QF4HAQ.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*21Rie9n9o92D3km_QF4HAQ.png);"></a></div><p name="c4c7" id="c4c7" class="graf graf--p graf-after--mixtapeEmbed">In my experiments, I have noticed there are two approaches to developing an LLM flow that constructs Query statements. One option is to provide <a href="https://medium.com/neo4j/knowledge-graph-based-chatbot-with-gpt-3-and-neo4j-c4ebbd325ed" data-href="https://medium.com/neo4j/knowledge-graph-based-chatbot-with-gpt-3-and-neo4j-c4ebbd325ed" class="markup--anchor markup--p-anchor" target="_blank">example queries in the prompt</a> or use the <a href="https://towardsdatascience.com/fine-tuning-an-llm-model-with-h2o-llm-studio-to-generate-cypher-statements-3f34822ad5" data-href="https://towardsdatascience.com/fine-tuning-an-llm-model-with-h2o-llm-studio-to-generate-cypher-statements-3f34822ad5" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">examples to finetune an LLM model</a>. However, the limitation of this approach is that it requires some work to <em class="markup--em markup--p-em">produce the Cypher examples</em> upfront. Therefore, the example Cypher queries must be generated for each graph schema.</p><p name="2c7f" id="2c7f" class="graf graf--p graf-after--p">On the other hand, we can provide an LLM directly with schema information and let it construct Cypher statements based on graph schema information alone. Using the second approach, we could develop a generic Cypher statement model to produce Cypher statements for any input graph schema, as we eliminate the need for any additional work like generating example Cypher statements.</p><p name="18c1" id="18c1" class="graf graf--p graf-after--p">This blog post will show you <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">how to implement a Cypher statement-generating model by providing only the graph schema</em></strong> information. We will evaluate the model’s Cypher construction capabilities on three graphs with different graph schemas. Currently, the only model I recommend to generate Cypher statements based on only the provided graph schema is <strong class="markup--strong markup--p-strong">GPT-4</strong>. Other models like GPT-3.5-turbo or text-davinci-003 aren’t that great, and I have yet to find an open-source LLM model that would be good at following instructions in the prompt and GPT-4.</p><p name="c4d1" id="c4d1" class="graf graf--p graf-after--p">All the code is <a href="https://github.com/tomasonjo/blogs/blob/master/llm/generic_cypher_gpt4.ipynb" data-href="https://github.com/tomasonjo/blogs/blob/master/llm/generic_cypher_gpt4.ipynb" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">available on GitHub</a>.</p><div name="534a" id="534a" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://github.com/tomasonjo/blogs/blob/master/llm/generic_cypher_gpt4.ipynb" data-href="https://github.com/tomasonjo/blogs/blob/master/llm/generic_cypher_gpt4.ipynb" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://github.com/tomasonjo/blogs/blob/master/llm/generic_cypher_gpt4.ipynb"><strong class="markup--strong markup--mixtapeEmbed-strong">blogs/generic_cypher_gpt4.ipynb at master · tomasonjo/blogs</strong><br>github.com</a><a href="https://github.com/tomasonjo/blogs/blob/master/llm/generic_cypher_gpt4.ipynb" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="4b6f0c6e583ae6cab59811e2d24e2604" data-thumbnail-img-id="0*HKKMSLKatmHoCsLb" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*HKKMSLKatmHoCsLb);"></a></div><h4 name="c165" id="c165" class="graf graf--h4 graf-after--mixtapeEmbed">Experiment Setup</h4><p name="8292" id="8292" class="graf graf--p graf-after--h4">I have implemented a Python class that connects to a Neo4j instance and fetches the schema information when initialized. The graph schema information can then be used as input to GPT-4 model.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="5447" id="5447" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Neo4jGPTQuery</span>:<br />    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, url, user, password, openai_api_key</span>):<br />        self.driver = GraphDatabase.driver(url, auth=(user, password))<br />        openai.api_key = openai_api_key<br />        <span class="hljs-comment"># construct schema</span><br />        self.schema = self.generate_schema()</span></pre><p name="caa0" id="caa0" class="graf graf--p graf-after--pre">The graph schema is stored in a string format with the following structure:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="3168" id="3168" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">  <span class="hljs-string">f&quot;This is the schema representation of the Neo4j database.<br />  Node properties are the following:<br />  <span class="hljs-subst">{node_props}</span><br />  Relationship properties are the following:<br />  <span class="hljs-subst">{rel_props}</span><br />  Relationship point from source to target nodes<br />  <span class="hljs-subst">{rels}</span><br />  Make sure to respect relationship types and directions&quot;</span></span></pre><p name="fea1" id="fea1" class="graf graf--p graf-after--pre">You can check the code if you are interested in the specific Cypher statements to retrieve schema information.</p><p name="6857" id="6857" class="graf graf--p graf-after--p">Next, we need to do a bit of <em class="markup--em markup--p-em">prompt engineering</em> and create a <strong class="markup--strong markup--p-strong">system</strong> prompt for the GPT-4 model that will be used to translate natural language into Cypher statements.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="17de" id="17de" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_system_message</span>(<span class="hljs-params">self</span>):<br />    <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;&quot;&quot;<br />    Task: Generate Cypher queries to query a Neo4j graph database based on the provided schema definition.<br />    Instructions:<br />    Use only the provided relationship types and properties.<br />    Do not use any other relationship types or properties that are not provided.<br />    If you cannot generate a Cypher statement based on the provided schema, explain the reason to the user.<br />    Schema:<br />    <span class="hljs-subst">{self.schema}</span><br /><br />    Note: Do not include any explanations or apologies in your responses.<br />    &quot;&quot;&quot;</span></span></pre><blockquote name="734c" id="734c" class="graf graf--blockquote graf-after--pre">It’s interesting how I ended with the final system message to get GPT-4 following my instructions. At first, I wrote my directions as plain text and added some constraints. However, the model wasn’t doing exactly what I wanted, so I opened ChatGPT in a web browser and <strong class="markup--strong markup--blockquote-strong">asked GPT to rewrite my instructions in a manner that GPT-4 would understand</strong>. Finally, ChatGPT seems to understand what works best as GPT-4 prompts, as the model behaved much better with this new prompt structure.</blockquote><p name="aceb" id="aceb" class="graf graf--p graf-after--blockquote">Next, we need to define a function that will generate Cypher statements.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="2fde" id="2fde" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">def</span> <span class="hljs-title function_">construct_cypher</span>(<span class="hljs-params">self, question, history=<span class="hljs-literal">None</span></span>):<br />    messages = [<br />        {<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;system&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: self.get_system_message()},<br />        {<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: question},<br />    ]<br />    <span class="hljs-comment"># Used for Cypher healing flows</span><br />    <span class="hljs-keyword">if</span> history:<br />        messages.extend(history)<br /><br />    completions = openai.ChatCompletion.create(<br />        model=<span class="hljs-string">&quot;gpt-4&quot;</span>,<br />        temperature=<span class="hljs-number">0.0</span>,<br />        max_tokens=<span class="hljs-number">1000</span>,<br />        messages=messages<br />    )<br />    <span class="hljs-keyword">return</span> completions.choices[<span class="hljs-number">0</span>].message.content</span></pre><p name="67b0" id="67b0" class="graf graf--p graf-after--pre">The GPT-4 model uses the ChatCompletion endpoint, which uses a combination of <strong class="markup--strong markup--p-strong">system</strong>, <strong class="markup--strong markup--p-strong">user</strong>, and optional <strong class="markup--strong markup--p-strong">assistant</strong> messages when we want to ask follow-up questions. So, we always start with only the system and user message. However, if the generated Cypher statement has any syntax error, the <strong class="markup--strong markup--p-strong">self-healing flow</strong> will be started, where we include the error in the follow-up question so that GPT-4 can fix the query. Therefore, we have included the optional <strong class="markup--strong markup--p-strong">history</strong> parameter for Cypher self-healing flow.</p><p name="a2ba" id="a2ba" class="graf graf--p graf-after--p">Don’t worry if the self-healing Cypher flow is a bit confusing. After, you will see the following <code class="markup--code markup--p-code">run</code> function, everything will make sense.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="a834" id="a834" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, question, history=<span class="hljs-literal">None</span>, retry=<span class="hljs-literal">True</span></span>):<br />    <span class="hljs-comment"># Construct Cypher statement</span><br />    cypher = self.construct_cypher(question, history)<br />    <span class="hljs-built_in">print</span>(cypher)<br />    <span class="hljs-keyword">try</span>:<br />        <span class="hljs-keyword">return</span> self.query_database(cypher)<br />    <span class="hljs-comment"># If Cypher syntax error</span><br />    <span class="hljs-keyword">except</span> CypherSyntaxError <span class="hljs-keyword">as</span> e:<br />        <span class="hljs-comment"># If out of retries</span><br />        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> retry:<br />          <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Invalid Cypher syntax&quot;</span><br />        <span class="hljs-comment"># Self-healing Cypher flow by</span><br />        <span class="hljs-comment"># providing specific error to GPT-4</span><br />        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Retrying&quot;</span>)<br />        <span class="hljs-keyword">return</span> self.run(<br />            question,<br />            [<br />                {<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;assistant&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: cypher},<br />                {<br />                    <span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>,<br />                    <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">f&quot;&quot;&quot;This query returns an error: <span class="hljs-subst">{<span class="hljs-built_in">str</span>(e)}</span> <br />                    Give me a improved query that works without any explanations or apologies&quot;&quot;&quot;</span>,<br />                },<br />            ],<br />            retry=<span class="hljs-literal">False</span><br />        )</span></pre><ol class="postList"><li name="59dd" id="59dd" class="graf graf--li graf-after--pre">The run function starts by generating a Cypher statement.</li><li name="5f21" id="5f21" class="graf graf--li graf-after--li">Then, the generated Cypher statement is used to query the Neo4j database.</li><li name="ee21" id="ee21" class="graf graf--li graf-after--li">If the Cypher syntax is valid, the query results are returned.</li><li name="4e6e" id="4e6e" class="graf graf--li graf-after--li">However, suppose there is a Cypher syntax error.</li><li name="186b" id="186b" class="graf graf--li graf-after--li">In that case, we do a single follow-up to GPT-4, provide the generated Cypher statement it constructed in the previous call, and include the error from the Neo4j database. GPT-4 is quite good at fixing a Cypher statement when provided with the error.</li></ol><p name="8698" id="8698" class="graf graf--p graf-after--li">The self-healing Cypher flow was inspired by others who have used similar flows for Python and other code. However, I have limited the follow-up Cypher healing to only a single iteration. If the follow-up doesn’t provide a valid Cypher statement, the function returns the “Invalid Cypher syntax response.”</p><p name="d6bd" id="d6bd" class="graf graf--p graf-after--p">Let’s now test the capabilities of GPT-4 to construct Cypher statements based on the provided graph schema only.</p><h4 name="d057" id="d057" class="graf graf--h4 graf-after--p">Airport Routes Graph</h4><p name="e035" id="e035" class="graf graf--p graf-after--h4">We will begin with a simple airport route graph, available as the <a href="https://sandbox.neo4j.com/?usecase=graph-data-science2" data-href="https://sandbox.neo4j.com/?usecase=graph-data-science2" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">GDS project in Neo4j Sandbox</a>.</p><figure name="1ad3" id="1ad3" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*YENc6AAi5TUdYgD_1lUrhw.png" data-width="936" data-height="680" src="https://cdn-images-1.medium.com/max/800/1*YENc6AAi5TUdYgD_1lUrhw.png"><figcaption class="imageCaption">Airports graph schema. Image by the author.</figcaption></figure><p name="01e0" id="01e0" class="graf graf--p graf-after--figure">This graph schema is relatively simple. The graph contains information about airports and their routes. Information about the airport’s city, region, country, and continent is stored as separate nodes.</p><p name="fd43" id="fd43" class="graf graf--p graf-after--p">We can instantiate the Python class used to query the airport graph with the following Python code:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="d1e6" id="d1e6" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">gds_db = Neo4jGPTQuery(<br />    url=<span class="hljs-string">&quot;bolt://18.207.187.166:7687&quot;</span>,<br />    user=<span class="hljs-string">&quot;neo4j&quot;</span>,<br />    password=<span class="hljs-string">&quot;preferences-accomplishments-vent&quot;</span>,<br />    openai_api_key=openai_key,<br />)</span></pre><p name="0103" id="0103" class="graf graf--p graf-after--pre">Now we can begin our experiment. First, we will start with a simple question.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="3e7f" id="3e7f" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">gds_db.run(<span class="hljs-string">&quot;&quot;&quot;<br />What is the city with the most airports?<br />&quot;&quot;&quot;</span>)<br /><span class="hljs-comment">#MATCH (a:Airport)-[:IN_CITY]-&gt;(c:City)</span><br /><span class="hljs-comment">#RETURN c.name AS City, COUNT(a) AS NumberOfAirports</span><br /><span class="hljs-comment">#ORDER BY NumberOfAirports DESC</span><br /><span class="hljs-comment">#LIMIT 1</span><br /><span class="hljs-comment">#[[&#x27;City&#x27;, &#x27;NumberOfAirports&#x27;], [&#x27;London&#x27;, 6]]</span></span></pre><p name="315b" id="315b" class="graf graf--p graf-after--pre">Great start. The Cypher statement was correctly generated, and we found that London has six airports. Next, let’s try something more complex.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="0e27" id="0e27" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">gds_db.run(<span class="hljs-string">&quot;&quot;&quot;<br />calculate the minimum, maximum, average, and standard deviation of the <br />number of flights out of each airport.<br />&quot;&quot;&quot;</span>)<br /><span class="hljs-comment"># MATCH (a:Airport)-[r:HAS_ROUTE]-&gt;(:Airport)</span><br /><span class="hljs-comment"># WITH a, count(r) as num_flights</span><br /><span class="hljs-comment"># RETURN min(num_flights) as min_flights, max(num_flights) as max_flights,</span><br /><span class="hljs-comment">#       avg(num_flights) as avg_flights, stDev(num_flights) as stddev_flights</span><br /><span class="hljs-comment"># [[&#x27;min_flights&#x27;, &#x27;max_flights&#x27;, &#x27;avg_flights&#x27;, &#x27;stddev_flights&#x27;],</span><br /><span class="hljs-comment"># [1, 307, 20.905362776025285, 38.28730861505158]]</span></span></pre><p name="456f" id="456f" class="graf graf--p graf-after--pre">Quite nice. The GPT-4 model correctly assumed that flights relate to the <strong class="markup--strong markup--p-strong">HAS_ROUTE</strong> relationship. Additionally, it accurately aggregates flights per airport, then calculates the specified metrics.</p><p name="a208" id="a208" class="graf graf--p graf-after--p">Let’s now throw it a curveball. We will ask the model to calculate the variance since Cypher doesn’t have any built-in function to calculate the variance.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="d3ba" id="d3ba" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">gds_db.run(<span class="hljs-string">&quot;&quot;&quot;<br />calculate the variance of the number of flights out of each airport.<br />&quot;&quot;&quot;</span>)<br /><span class="hljs-comment">#To calculate the variance of the number of flights out of each airport,</span><br /><span class="hljs-comment">#we first need to calculate the average number of flights and then use this </span><br /><span class="hljs-comment"># value to calculate the variance. Here are the Cypher queries to achieve this:</span><br /><span class="hljs-comment">#</span><br /><span class="hljs-comment">#1. Calculate the average number of flights out of each airport:</span><br /><span class="hljs-comment">#</span><br /><span class="hljs-comment">#```</span><br /><span class="hljs-comment">#MATCH (a:Airport)-[r:HAS_ROUTE]-&gt;()</span><br /><span class="hljs-comment">#WITH COUNT(r) AS num_flights</span><br /><span class="hljs-comment">#RETURN AVG(num_flights) AS average_flights</span><br /><span class="hljs-comment">#```</span><br /><span class="hljs-comment">#</span><br /><span class="hljs-comment">#2. Calculate the variance of the number of flights out of each airport:</span><br /><span class="hljs-comment">#</span><br /><span class="hljs-comment">#```</span><br /><span class="hljs-comment">#MATCH (a:Airport)-[r:HAS_ROUTE]-&gt;()</span><br /><span class="hljs-comment">#WITH COUNT(r) AS num_flights</span><br /><span class="hljs-comment">#WITH AVG(num_flights) AS average_flights, COLLECT(num_flights) AS flights</span><br /><span class="hljs-comment">#UNWIND flights AS flight</span><br /><span class="hljs-comment">#WITH average_flights, SUM((flight - average_flights) ^ 2) / COUNT(flight) AS variance</span><br /><span class="hljs-comment">#RETURN variance</span><br /><span class="hljs-comment">#```</span></span></pre><p name="d1fe" id="d1fe" class="graf graf--p graf-after--pre">First of all, GPT-4 provided explanations when explicitly told not to. Secondly, neither Cypher statements make any sense. In this example, even the self-healing flow didn’t succeed since we are not dealing with a Cypher syntax error but a GPT-4 system malfunction.</p><p name="d15e" id="d15e" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">I have noticed that GPT-4 struggles when it needs to perform multiple aggregations using different grouping keys in a single Cypher statement. Here it wanted to split the statement into two parts (which doesn’t work either), but in other cases, it wants to borrow syntax from SQL.</em></p><p name="5bed" id="5bed" class="graf graf--p graf-after--p">However, GPT-4 is quite obedient and provides the specified results from the database as instructed by the user.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="1f45" id="1f45" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">gds_db.run(<span class="hljs-string">&quot;&quot;&quot;<br />Find the shortest route between ATL and IAH airports<br />and return only the iata and runways property of the nodes as a map object<br />&quot;&quot;&quot;</span>)<br /><span class="hljs-comment">#MATCH (atl:Airport {iata: &quot;ATL&quot;}), (iah:Airport {iata: &quot;IAH&quot;}), </span><br /><span class="hljs-comment">#path = shortestPath((atl)-[:HAS_ROUTE*]-(iah))</span><br /><span class="hljs-comment">#WITH nodes(path) AS airports</span><br /><span class="hljs-comment">#UNWIND airports AS airport</span><br /><span class="hljs-comment">#RETURN {iata: airport.iata, runways: airport.runways} AS airport_map</span><br /><span class="hljs-comment">#[[&#x27;airport_map&#x27;],</span><br /><span class="hljs-comment"># [{&#x27;iata&#x27;: &#x27;ATL&#x27;, &#x27;runways&#x27;: 5}],</span><br /><span class="hljs-comment"># [{&#x27;iata&#x27;: &#x27;IAH&#x27;, &#x27;runways&#x27;: 5}]]</span></span></pre><p name="d841" id="d841" class="graf graf--p graf-after--pre">Here is where the power of GPT-4 shines. The more specific we are in what we want to find and how we want the results to be structured, the better it works.</p><p name="f7c6" id="f7c6" class="graf graf--p graf-after--p">We can also test if it knows how to use the GDS library.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="c807" id="c807" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-built_in">print</span>(gds_db.construct_cypher(<span class="hljs-string">&quot;&quot;&quot;<br />Calculate the betweenness centrality of airports using the <br />Graph Data Science library<br />&quot;&quot;&quot;</span>))<br /><span class="hljs-comment">#CALL gds.betweenness.stream({</span><br /><span class="hljs-comment"># nodeProjection: &#x27;Airport&#x27;,</span><br /><span class="hljs-comment"># relationshipProjection: {</span><br /><span class="hljs-comment">#   HAS_ROUTE: {</span><br /><span class="hljs-comment">#     type: &#x27;HAS_ROUTE&#x27;,</span><br /><span class="hljs-comment">#     orientation: &#x27;UNDIRECTED&#x27;</span><br /><span class="hljs-comment">#   }</span><br /><span class="hljs-comment"># }</span><br /><span class="hljs-comment">#})</span><br /><span class="hljs-comment">#YIELD nodeId, score</span><br /><span class="hljs-comment">#RETURN gds.util.asNode(nodeId).id AS airportId, gds.util.asNode(nodeId).icao AS airportICAO, score</span><br /><span class="hljs-comment">#ORDER BY score DESC</span></span></pre><p name="eb6c" id="eb6c" class="graf graf--p graf-after--pre">Well, the constructed Cypher statement looks fine. However, there is only one problem. The generated Cypher statement uses the anonymous graph projection, which was deprecated and removed in GDS v2. Here we see some issues arising from GPT -4’s knowledge cutoff date. Unfortunately, it looks like GDS v2 was released after the knowledge cutoff date, and therefore the new syntax is not baked into GPT-4. Therefore, at the moment, the GPT-4 model doesn’t provide valid GDS procedures.</p><p name="cc75" id="cc75" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">If you pay attention, you will also notice that GPT-4 never uses the Cypher subquery syntax, which is another syntax change added after the knowledge cutoff date.</em></p><p name="981e" id="981e" class="graf graf--p graf-after--p">Interestingly, if you calculate any of the values from graph algorithms and store them as node property, the GPT-4 has no problem retrieving that.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="1063" id="1063" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">gds_db.run(<span class="hljs-string">&quot;&quot;&quot;<br />Use PageRank to find the five most important airports and return <br />their descr and pagerank value<br />&quot;&quot;&quot;</span>)<br /><span class="hljs-comment">#MATCH (a:Airport)</span><br /><span class="hljs-comment">#RETURN a.descr, a.pagerank</span><br /><span class="hljs-comment">#ORDER BY a.pagerank DESC</span><br /><span class="hljs-comment">#LIMIT 5</span><br /><span class="hljs-comment">#[[&#x27;a.descr&#x27;, &#x27;a.pagerank&#x27;],</span><br /><span class="hljs-comment"># [&#x27;Dallas/Fort Worth International Airport&#x27;, 11.97978260670334],</span><br /><span class="hljs-comment"># [&quot;Chicago O&#x27;Hare International Airport&quot;, 11.162988178920267],</span><br /><span class="hljs-comment"># [&#x27;Denver International Airport&#x27;, 10.997299338126387],</span><br /><span class="hljs-comment"># [&#x27;Hartsfield - Jackson Atlanta International Airport&#x27;, 10.389948350302957],</span><br /><span class="hljs-comment"># [&#x27;Istanbul International Airport&#x27;, 8.42580121770578]]</span></span></pre><p name="cd27" id="cd27" class="graf graf--p graf-after--pre">It looks like Dallas and Chicago have the highest PageRank scores.</p><h4 name="3169" id="3169" class="graf graf--h4 graf-after--p">Healthcare Sandbox</h4><p name="6a91" id="6a91" class="graf graf--p graf-after--h4">You might say that the airport sandbox might have been part of the training data of GPT-4. That is a possibility. Therefore, let’s test GPT-4 ability to construct Cypher statements on the latest Neo4j Sandbox project dealing with healthcare data, published between December 2022 and January 2023. That should be after the GPT-4 knowledge cutoff date.</p><figure name="e96e" id="e96e" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Izrxv6d0Fzr5SdkSaH2FNg.png" data-width="705" data-height="539" src="https://cdn-images-1.medium.com/max/800/1*Izrxv6d0Fzr5SdkSaH2FNg.png"><figcaption class="imageCaption">Healthcare graph schema. Image by the author.</figcaption></figure><p name="558f" id="558f" class="graf graf--p graf-after--figure">The healthcare graph schema revolves around adverse drug event cases. Therefore, each case is related to relevant drugs. In addition, other information is available such as the age group, outcome, and reaction. Here, I took the examples from the sandbox guide as I am not familiar with the adverse drug events domain.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="5033" id="5033" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">hc_db.run(<span class="hljs-string">&quot;&quot;&quot;<br />What are the top 5 side effects reported?<br />&quot;&quot;&quot;</span>)<br /><span class="hljs-comment">#MATCH (c:Case)-[:HAS_REACTION]-&gt;(r:Reaction)</span><br /><span class="hljs-comment">#RETURN r.description as SideEffect, COUNT(*) as Frequency</span><br /><span class="hljs-comment">#ORDER BY Frequency DESC</span><br /><span class="hljs-comment">#LIMIT 5</span><br /><span class="hljs-comment">#[[&#x27;SideEffect&#x27;, &#x27;Frequency&#x27;],</span><br /><span class="hljs-comment"># [&#x27;Fatigue&#x27;, 303],</span><br /><span class="hljs-comment"># [&#x27;Product dose omission issue&#x27;, 285],</span><br /><span class="hljs-comment"># [&#x27;Headache&#x27;, 272],</span><br /><span class="hljs-comment"># [&#x27;Nausea&#x27;, 256],</span><br /><span class="hljs-comment"># [&#x27;Pain&#x27;, 253]]</span></span></pre><p name="fd8c" id="fd8c" class="graf graf--p graf-after--pre">It would be interesting to learn how did GPT-4 know that side effects can be found as the <strong class="markup--strong markup--p-strong">Reaction</strong> nodes. Even I couldn’t find that without any details about the graph. Are there graphs out there with a similar schema, or is the knowledge cutoff date of GPT-4 not that accurate? Or does it only have great intuition to find relevant data based on node labels and their properties?</p><p name="2289" id="2289" class="graf graf--p graf-after--p">Let’s try something more complex.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="805b" id="805b" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">hc_db.run(<span class="hljs-string">&quot;&quot;&quot;<br />What are the top 3 manufacturing companies with the most reported side effects?<br />&quot;&quot;&quot;</span>)<br /><span class="hljs-comment">#MATCH (m:Manufacturer)-[:REGISTERED]-&gt;(c:Case)-[:HAS_REACTION]-&gt;(r:Reaction)</span><br /><span class="hljs-comment">#RETURN m.manufacturerName, COUNT(r) as sideEffectsCount</span><br /><span class="hljs-comment">#ORDER BY sideEffectsCount DESC</span><br /><span class="hljs-comment">#LIMIT 3</span><br /><span class="hljs-comment">#[[&#x27;m.manufacturerName&#x27;, &#x27;sideEffectsCount&#x27;],</span><br /><span class="hljs-comment"># [&#x27;TAKEDA&#x27;, 5058],</span><br /><span class="hljs-comment"># [&#x27;PFIZER&#x27;, 3219],</span><br /><span class="hljs-comment"># [&#x27;NOVARTIS&#x27;, 1823]]</span></span></pre><p name="07d1" id="07d1" class="graf graf--p graf-after--pre">We can see that GPT-4 is very specific in our request. Since we are asking for the count of reported side effects, it expands to <strong class="markup--strong markup--p-strong">Reaction</strong> nodes and counts them. On the other hand, we could request only the number of cases.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="29d2" id="29d2" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">hc_db.run(<span class="hljs-string">&quot;&quot;&quot;<br />What are the top 3 manufacturing companies with the most reported cases?<br />&quot;&quot;&quot;</span>)<br /><span class="hljs-comment">#MATCH (m:Manufacturer)-[:REGISTERED]-&gt;(c:Case)</span><br /><span class="hljs-comment">#RETURN m.manufacturerName, COUNT(c) as case_count</span><br /><span class="hljs-comment">#ORDER BY case_count DESC</span><br /><span class="hljs-comment">#LIMIT 3</span><br /><span class="hljs-comment">#[[&#x27;m.manufacturerName&#x27;, &#x27;case_count&#x27;],</span><br /><span class="hljs-comment"># [&#x27;TAKEDA&#x27;, 617],</span><br /><span class="hljs-comment"># [&#x27;CELGENE&#x27;, 572],</span><br /><span class="hljs-comment"># [&#x27;PFIZER&#x27;, 513]]</span></span></pre><p name="b126" id="b126" class="graf graf--p graf-after--pre">Now, let’s do something where GPT-4 has to do both filtering and aggregating.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="7c0c" id="7c0c" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">hc_db.run(<span class="hljs-string">&quot;&quot;&quot;<br />What are the top 5 drugs whose side effects resulted in death of patients <br />as an outcome?<br />&quot;&quot;&quot;</span>)<br /><span class="hljs-comment">#MATCH (d:Drug)-[:IS_PRIMARY_SUSPECT|:IS_SECONDARY_SUSPECT|:IS_CONCOMITANT|:IS_INTERACTING]-&gt;(c:Case)-[:HAS_REACTION]-&gt;(r:Reaction), </span><br /><span class="hljs-comment">#      (c)-[:RESULTED_IN]-&gt;(o:Outcome)</span><br /><span class="hljs-comment">#WHERE o.outcome = &quot;Death&quot;</span><br /><span class="hljs-comment">#RETURN d.name, COUNT(*) as DeathCount</span><br /><span class="hljs-comment">#ORDER BY DeathCount DESC</span><br /><span class="hljs-comment">#LIMIT 5</span><br /><span class="hljs-comment">#[[&#x27;d.name&#x27;, &#x27;DeathCount&#x27;]]</span></span></pre><p name="f193" id="f193" class="graf graf--p graf-after--pre">Something that happens sometimes is that GPT-4 messes up the relationship direction. For example, the relationships from the <strong class="markup--strong markup--p-strong">Drug</strong> to the <strong class="markup--strong markup--p-strong">Case</strong> node should have a reverse direction. Additionally, the Sandbox guide uses only the <strong class="markup--strong markup--p-strong">IS_PRIMARY_SUSPECT</strong> relationship type, but we can’t blame the GPT-4 model due to the question’s ambiguity.</p><p name="9d9a" id="9d9a" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">Note that GPT-4 is not deterministic. Therefore, it may return correct relationship directions and sometimes not. For me, it worked correctly one day and not the other.</em></p><p name="05bd" id="05bd" class="graf graf--p graf-after--p">What I found interesting is that the GPT-4 model knew that the outcome property contains information about the death of patients. But more than that, it knew that the death value should be capitalized, which makes me think the model saw this dataset in one form or another. Or maybe GPT-4 just likes to capitalize property values.</p><h4 name="eb0a" id="eb0a" class="graf graf--h4 graf-after--p">Custom Astronomical Dataset</h4><p name="3b03" id="3b03" class="graf graf--p graf-after--h4">I have decided to construct a custom astronomical dataset that the model definitely hasn’t seen during its training since it didn’t exist until I started writing this post. It is tiny but good enough to test GPT-4 generalization ability. I created a <a href="https://sandbox.neo4j.com/?usecase=blank-sandbox" data-href="https://sandbox.neo4j.com/?usecase=blank-sandbox" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">blank project on Neo4j Sandbox</a> and seeded the database with the following script.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="3ce6" id="3ce6" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">astro_db = Neo4jGPTQuery(<br />    url=<span class="hljs-string">&quot;bolt://35.171.160.87:7687&quot;</span>,<br />    user=<span class="hljs-string">&quot;neo4j&quot;</span>,<br />    password=<span class="hljs-string">&quot;discontinuance-fifths-sports&quot;</span>,<br />    openai_api_key=openai_key,<br />)<br />url = <span class="hljs-string">&quot;https://gist.githubusercontent.com/tomasonjo/52b2da916ef5cd1c2adf0ad62cc71a26/raw/a3a8716f7b28f3a82ce59e6e7df28389e3cb33cb/astro.cql&quot;</span><br />astro_db.query_database(<span class="hljs-string">&quot;CALL apoc.cypher.runFile($url)&quot;</span>, {<span class="hljs-string">&#x27;url&#x27;</span>:url})<br />astro_db.refresh_schema()</span></pre><p name="413a" id="413a" class="graf graf--p graf-after--pre">The constructed graph has the following schema.</p><figure name="2212" id="2212" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*mZreNZZhnZsMu8eWL3MJ6g.png" data-width="703" data-height="385" src="https://cdn-images-1.medium.com/max/800/1*mZreNZZhnZsMu8eWL3MJ6g.png"><figcaption class="imageCaption">Astronomical graph schema. Image by the author.</figcaption></figure><p name="8662" id="8662" class="graf graf--p graf-after--figure">The database contains planets within our solar system that orbit the sun. Additionally, satellites like ISS, the moon, and Hubble Telescope are included.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="b354" id="b354" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">astro_db.run(<span class="hljs-string">&quot;&quot;&quot;<br />What orbits the Earth?<br />&quot;&quot;&quot;</span>)<br /><span class="hljs-comment">#MATCH (s:Satellite)-[:ORBITS]-&gt;(a:AstronomicalObject {name: &quot;Earth&quot;})</span><br /><span class="hljs-comment">#RETURN s.name as SatelliteName</span><br /><span class="hljs-comment">#[[&#x27;Hubble Space Telescope&#x27;], [&#x27;ISS&#x27;], [&#x27;Moon&#x27;]]</span></span></pre><p name="b03a" id="b03a" class="graf graf--p graf-after--pre">Remember, the GPT-4 only know that there are satellites and astronomical objects in the database. Astronomical objects orbit other astronomical objects, while satellites can only orbit objects. It looks like it used its knowledge to assume that only a satellite would orbit the Earth, which is impressive. We can observe that GPT-4 probably makes many assumptions based on its baked knowledge to help us with our queries.</p><p name="8858" id="8858" class="graf graf--p graf-after--p">Let’s dig deeper.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="e92d" id="e92d" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">astro_db.run(<span class="hljs-string">&quot;&quot;&quot;<br />Does ISS orbits the Sun?<br />&quot;&quot;&quot;</span>)<br /><span class="hljs-comment">#MATCH (s:Satellite)-[:ORBITS]-&gt;(a:AstronomicalObject)</span><br /><span class="hljs-comment">#WHERE s.name = &quot;ISS&quot; AND a.name = &quot;Sun&quot;</span><br /><span class="hljs-comment">#RETURN s, a</span><br /><span class="hljs-comment">#[]</span></span></pre><p name="9724" id="9724" class="graf graf--p graf-after--pre">So, the ISS doesn’t directly orbit the sun. We can rephrase our question.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="51ed" id="51ed" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">astro_db.run(<span class="hljs-string">&quot;&quot;&quot;<br />Does ISS orbits the Sun? Find any path between them<br />and return names of nodes in the path<br />&quot;&quot;&quot;</span>)<br /><span class="hljs-comment">#MATCH path = (iss:Satellite {name: &quot;ISS&quot;})-[:ORBITS*]-&gt;(sun:AstronomicalObject {name: &quot;Sun&quot;})</span><br /><span class="hljs-comment">#RETURN [node in nodes(path) | node.name] AS path_names</span><br /><span class="hljs-comment">#[[&#x27;path_names&#x27;], [[&#x27;ISS&#x27;, &#x27;Earth&#x27;, &#x27;Sun&#x27;]]]</span></span></pre><p name="1fde" id="1fde" class="graf graf--p graf-after--pre">Now, it uses a variable-length path pattern to find if ISS orbits the sun by proxy. Of course, we gave it a hint to use that, but it is still remarkable. For the final example, let’s observe how good GPT-4 is at guessing never-seen-before property values.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="a4ba" id="a4ba" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">astro_db.run(<span class="hljs-string">&quot;&quot;&quot;<br />What&#x27;s the altitude difference between ISS and Hubble telescope<br />&quot;&quot;&quot;</span>)<br /><span class="hljs-comment">#MATCH (s1:Satellite {name: &quot;ISS&quot;}), (s2:Satellite {name: &quot;Hubble Telescope&quot;})</span><br /><span class="hljs-comment">#RETURN abs(s1.altitude - s2.altitude) AS altitude_difference</span><br /><span class="hljs-comment">#[[&#x27;altitude_difference&#x27;]]</span></span></pre><p name="a9ce" id="a9ce" class="graf graf--p graf-after--pre">To tell you the truth, I am relieved GPT-4 didn’t guess correctly that Hubble is stored in the database as “Hubble Space Telescope.”” Other than that, the generated Cypher statement is perfectly valid.</p><h4 name="3ae1" id="3ae1" class="graf graf--h4 graf-after--p">Summary</h4><p name="584a" id="584a" class="graf graf--p graf-after--h4">GPT-4 has a great potential to generate Cypher statements based on only the provided graph schema. I think it has seen many datasets and graph models during its training, so it is good at guessing which properties to use and sometimes even their values. However, you can always provide the model with instructions about which properties to use and specify the exact values if the model isn’t performing well on your specific graph model. The limitations I have observed during this experiment are the following:</p><ul class="postList"><li name="4a5f" id="4a5f" class="graf graf--li graf-after--p">Multiple aggregations with different grouping keys are a problem</li><li name="bf90" id="bf90" class="graf graf--li graf-after--li">Version two of the Graph Data Science library is beyond the knowledge cutoff date</li><li name="7e5e" id="7e5e" class="graf graf--li graf-after--li">Sometimes it messes up the relationship direction (not frequently, though)</li><li name="ef9d" id="ef9d" class="graf graf--li graf-after--li">The non-deterministic nature of GPT-4 makes it feel like you are dealing with a horoscope-based model, where identical queries work in the morning but not in the afternoon</li><li name="be53" id="be53" class="graf graf--li graf-after--li">Sometimes the model bypasses system instructions and provides explanations for queries</li></ul><p name="836e" id="836e" class="graf graf--p graf-after--li">Using the schema-only approach to GPT-4 can be used for experimental setups to help developers or researchers that don’t have malicious intents to interact with the graph database. On the other hand, if you want to build something more production-ready, I recommend providing examples of Cypher statements.</p><p name="b579" id="b579" class="graf graf--p graf-after--p">To learn more about this topic, join me at NODES 2023, a free online global conference about graph technologies. The CFP is open now until June 30. <a href="https://dev.neo4j.com/nodes23" data-href="https://dev.neo4j.com/nodes23" class="markup--anchor markup--p-anchor" rel="noopener noreferrer noopener" target="_blank">https://dev.neo4j.com/nodes23</a></p><p name="9f2a" id="9f2a" class="graf graf--p graf-after--p graf--trailing">As always, the <a href="https://github.com/tomasonjo/blogs/blob/master/llm/generic_cypher_gpt4.ipynb" data-href="https://github.com/tomasonjo/blogs/blob/master/llm/generic_cypher_gpt4.ipynb" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">code is available on GitHub</a>.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@bratanic-tomaz" class="p-author h-card">Tomaz Bratanic</a> on <a href="https://medium.com/p/a57d7082a7e7"><time class="dt-published" datetime="2023-05-02T13:49:36.039Z">May 2, 2023</time></a>.</p><p><a href="https://medium.com/@bratanic-tomaz/generating-cypher-queries-with-chatgpt-4-on-any-graph-schema-a57d7082a7e7" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on November 5, 2023.</p></footer></article></body></html>