<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>How to use Cypher Aggregations in Neo4j Graph Data Science library</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">How to use Cypher Aggregations in Neo4j Graph Data Science library</h1>
</header>
<section data-field="subtitle" class="p-summary">
Leverage Cypher Aggregation feature to project in-memory graphs using all the flexibility and expressiveness of Cypher query language
</section>
<section data-field="body" class="e-content">
<section name="e250" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="5e4c" id="5e4c" class="graf graf--h3 graf--leading graf--title">How to use Cypher Aggregations in Neo4j Graph Data Science library</h3><h4 name="dd25" id="dd25" class="graf graf--h4 graf-after--h3 graf--subtitle">Leverage Cypher Aggregation feature to project in-memory graphs using all the flexibility and expressiveness of Cypher query language</h4><p name="e135" id="e135" class="graf graf--p graf-after--h4">Cypher Aggregation is a powerful feature of the Neo4j Graph Data Science library that allows users to project an in-memory graph using a flexible and expressive approach. While it was possible to use Cypher statements to project an in-memory graph for quite some time using Cypher Projection, it lacked some features, most notably the ability to project undirected relationships. Therefore, a new approach to projecting an in-memory graph in GDS was added called Cypher Aggregation. This blog post will explore the syntax and common usage of the Cypher Aggregation projection option in the Neo4j Graph Data Science Library.</p><h4 name="18bb" id="18bb" class="graf graf--h4 graf-after--p">Environment setup</h4><p name="c699" id="c699" class="graf graf--p graf-after--h4">If you want to follow along with the examples, you can open a <a href="https://sandbox.neo4j.com/?usecase=graph-data-science2" data-href="https://sandbox.neo4j.com/?usecase=graph-data-science2" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Graph Data Science project in Neo4j Sandbox</a>. The project has a small dataset containing information about airports, their locations, and flight routes.</p><p name="b23c" id="b23c" class="graf graf--p graf-after--p">We can visualize the graph schema with the following Cypher statement:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="graphql" name="968d" id="968d" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">CALL db.<span class="hljs-keyword">schema</span>.visualization<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span></span></pre><figure name="9dd1" id="9dd1" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*k28RS-1ljU1zYsbpvFI8qg.png" data-width="980" data-height="773" src="https://cdn-images-1.medium.com/max/800/1*k28RS-1ljU1zYsbpvFI8qg.png"><figcaption class="imageCaption">Graph schema. Image by the author.</figcaption></figure><h4 name="8917" id="8917" class="graf graf--h4 graf-after--figure">Projecting in-memory graphs with Cypher aggregation</h4><p name="a681" id="a681" class="graf graf--p graf-after--h4">First, let’s quickly revisit how the Neo4j Graph Data Science library operates.</p><figure name="6715" id="6715" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*FJMcnjmKicgKolSP3Y937A.png" data-width="385" data-height="375" src="https://cdn-images-1.medium.com/max/800/1*FJMcnjmKicgKolSP3Y937A.png"><figcaption class="imageCaption">Graph Data Science library workflow. Image by the author.</figcaption></figure><p name="438b" id="438b" class="graf graf--p graf-after--figure">Before we can execute any graph algorithms, we first have to project an in-memory graph. The in-memory graph does not have to be an exact copy of the stored graph in the database. We have the ability to select only a subset of graph, or as you will learn later also project virtual relationships that are not stored in the database. After the in-memory graph is projected, we have can execute how many graph algorithms we want, and then either stream the results directly to the user, or write them back to the database.</p><h4 name="18ff" id="18ff" class="graf graf--h4 graf-after--p">Projecting an in-memory graph with Cypher Aggregation</h4><p name="22d9" id="22d9" class="graf graf--p graf-after--h4">Cypher Aggregation feature is part of the first step in Graph Data Science workflow, which is projecting an in-memory graph. It offers full flexibility of Cypher query language to select, filter, or transform a graph during projection. The syntax of the Cypher Aggregation function is the following:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="sql" name="318d" id="318d" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">gds.alpha.graph.project(<br />    graphName: String,<br />    sourceNode: Node <span class="hljs-keyword">or</span> <span class="hljs-type">Integer</span>,<br />    targetNode: Node <span class="hljs-keyword">or</span> <span class="hljs-type">Integer</span>,<br />    nodesConfig: Map,<br />    relationshipConfig: Map,<br />    configuration: Map<br />)</span></pre><p name="76b8" id="76b8" class="graf graf--p graf-after--pre">Only the first two parameters (graphName as sourceNode) are mandatory, however, you need to specify both the sourceNode and relationshipNode parameters to define a single relationship. We will walk through most of the options you might need to help you project graphs with Cypher Aggregation.</p><p name="1e12" id="1e12" class="graf graf--p graf-after--p">We will start with a simple example. Let’s say we want to project all <strong class="markup--strong markup--p-strong">Airport</strong> nodes and the <strong class="markup--strong markup--p-strong">HAS_ROUTE</strong> relationship between them.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="sql" name="e42d" id="e42d" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">MATCH</span> (source:Airport)<span class="hljs-operator">-</span>[:HAS_ROUTE]<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>(target:Airport)<br /><span class="hljs-keyword">WITH</span> gds.alpha.graph.project(<span class="hljs-string">&#x27;airports&#x27;</span>, source, target) <span class="hljs-keyword">AS</span> graph<br /><span class="hljs-keyword">RETURN</span> graph.nodeCount <span class="hljs-keyword">AS</span> nodeCount, <br />       graph.relationshipCount <span class="hljs-keyword">AS</span> relationshipCount</span></pre><p name="46db" id="46db" class="graf graf--p graf-after--pre">The Cypher statements starts with a MATCH clause that selects the relevant graph. To define a relationship with Cypher Aggregation, we input both the <strong class="markup--strong markup--p-strong">source</strong> and <strong class="markup--strong markup--p-strong">target</strong> node.</p><p name="5738" id="5738" class="graf graf--p graf-after--p">Of course, the Cypher query language offers flexibility to select any subset of the graph. So, for example, we could project only airports in the Oceania content and their flight routes.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="sql" name="1b18" id="1b18" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">MATCH</span> (source:Airport)<span class="hljs-operator">-</span>[:HAS_ROUTE]<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>(target:Airport)<br /><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span> {(source)<span class="hljs-operator">-</span>[:ON_CONTINENT]<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>(:Continent {name:&quot;OC&quot;})}<br />  <span class="hljs-keyword">AND</span> <span class="hljs-keyword">EXISTS</span> {(target)<span class="hljs-operator">-</span>[:ON_CONTINENT]<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>(:Continent {name:&quot;OC&quot;})}<br /><span class="hljs-keyword">WITH</span> gds.alpha.graph.project(<span class="hljs-string">&#x27;airports-oceania&#x27;</span>, source, target) <span class="hljs-keyword">AS</span> graph<br /><span class="hljs-keyword">RETURN</span> graph.nodeCount <span class="hljs-keyword">AS</span> nodeCount, <br />       graph.relationshipCount <span class="hljs-keyword">AS</span> relationshipCount</span></pre><p name="48bf" id="48bf" class="graf graf--p graf-after--pre">The matching Cypher statement became slightly more complicated in this example, but the Cypher Aggregation function stayed the same. The <strong class="markup--strong markup--p-strong">airports-oceania</strong> graph contains 272 nodes and 973 relationships. If you are experienced with Cypher, you might notice that the above Cypher statement will not capture any airports in Oceania that don’t have flight routes with other airports in Oceania.</p><p name="551b" id="551b" class="graf graf--p graf-after--p">Suppose we want to project isolated airports in the projection as well. In that case, we need to modify the Cypher matching statement slightly.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="sql" name="4cc0" id="4cc0" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">MATCH</span> (source:Airport)<br /><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span> {(source)<span class="hljs-operator">-</span>[:ON_CONTINENT]<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>(:Continent {name:&quot;OC&quot;})}<br />OPTIONAL <span class="hljs-keyword">MATCH</span> (source)<span class="hljs-operator">-</span>[:HAS_ROUTE]<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>(target:Airport)<br /><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span> {(target)<span class="hljs-operator">-</span>[:ON_CONTINENT]<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>(:Continent {name:&quot;OC&quot;})}<br /><span class="hljs-keyword">WITH</span> gds.alpha.graph.project(<span class="hljs-string">&#x27;airports-isolated&#x27;</span>, source, target) <span class="hljs-keyword">AS</span> graph<br /><span class="hljs-keyword">RETURN</span> graph.nodeCount <span class="hljs-keyword">AS</span> nodeCount, graph.relationshipCount <span class="hljs-keyword">AS</span> relationshipCount</span></pre><p name="4809" id="4809" class="graf graf--p graf-after--pre">The relationship count remains identical, while the node count has increased to 304. Therefore, 32 airports in Oceania don’t have any flight routes to other airports in Oceania.</p><p name="a723" id="a723" class="graf graf--p graf-after--p">When dealing with multiple node and relationship types in a graph, we might want to retain information about node labels and relationship types during projection. Defining the node and relationship types during graph projection allows us to filter them at algorithm execution time.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="sql" name="a1bb" id="a1bb" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">CALL</span> {<br />    <span class="hljs-keyword">MATCH</span> (source:Airport)<span class="hljs-operator">-</span>[r:HAS_ROUTE]<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>(target:Airport)<br />    <span class="hljs-keyword">RETURN</span> source, target, r<br />    <span class="hljs-keyword">UNION</span><br />    <span class="hljs-keyword">MATCH</span> (source:Airport)<span class="hljs-operator">-</span>[r:IN_CITY]<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>(target:City)<br />    <span class="hljs-keyword">RETURN</span> source, target, r<br />}<br /><span class="hljs-keyword">WITH</span> gds.alpha.graph.project(<span class="hljs-string">&#x27;airports-labels&#x27;</span>, source, target,<br />  {sourceNodeLabels: labels(source),<br />   targetNodeLabels: labels(target)},<br />  {relationshipType:type(r)}) <span class="hljs-keyword">AS</span> graph<br /><span class="hljs-keyword">RETURN</span> graph.nodeCount <span class="hljs-keyword">AS</span> nodeCount, graph.relationshipCount <span class="hljs-keyword">AS</span> relationshipCount</span></pre><p name="27ac" id="27ac" class="graf graf--p graf-after--pre">I prefer using <code class="markup--code markup--p-code">UNION</code> clause when projecting multiple different graph patterns. However, what Cypher matching statement is entirely up to you. Since we are projecting two types of nodes and relationships, it is probably a good idea to retain the information about their labels and types. Therefore, we are using the <strong class="markup--strong markup--p-strong">sourceNodeLabels</strong>, <strong class="markup--strong markup--p-strong">targetNodeLabels</strong>, and <strong class="markup--strong markup--p-strong">relationshipType</strong> parameters. In this example, we use the existing node labels and relationship types.</p><p name="0d9b" id="0d9b" class="graf graf--p graf-after--p">However, sometimes we might want to use custom labels or relationship types during projection.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="sql" name="8f7a" id="8f7a" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">CALL</span> {<br />    <span class="hljs-keyword">MATCH</span> (source:Airport)<span class="hljs-operator">-</span>[r:HAS_ROUTE]<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>(target:Airport)<br />    <span class="hljs-keyword">RETURN</span> source, target, r<br />    <span class="hljs-keyword">UNION</span><br />    <span class="hljs-keyword">MATCH</span> (source:Airport)<span class="hljs-operator">-</span>[r:IN_CITY]<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>(target:City)<br />    <span class="hljs-keyword">RETURN</span> source, target, r<br />}<br /><span class="hljs-keyword">WITH</span> gds.alpha.graph.project(<span class="hljs-string">&#x27;airports-labels-custom&#x27;</span>, source, target,<br />{sourceNodeLabels: <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> source.city <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Miami&#x27;</span> <br />                       <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;Miami&#x27;</span> <span class="hljs-keyword">ELSE</span> <span class="hljs-string">&#x27;NotMiami&#x27;</span> <span class="hljs-keyword">END</span>,<br /> targetNodeLabels: [<span class="hljs-string">&#x27;CustomLabel&#x27;</span>]},<br />{relationshipType: <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> type(r) <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;HAS_ROUTE&#x27;</span> <br />                        <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;FLIGHT&#x27;</span> <span class="hljs-keyword">ELSE</span> <span class="hljs-string">&#x27;NOT_FLIGHT&#x27;</span> <span class="hljs-keyword">END</span>}) <span class="hljs-keyword">AS</span> graph<br /><span class="hljs-keyword">RETURN</span> graph.nodeCount <span class="hljs-keyword">AS</span> nodeCount, graph.relationshipCount <span class="hljs-keyword">AS</span> relationshipCount</span></pre><p name="7419" id="7419" class="graf graf--p graf-after--pre">As you can see, we can use Cypher to dynamically define the node or relationship type or simply hardcode it. The custom node label or relationship type can also be calculated in the Cypher matching statement if it is more complicated.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="sql" name="2103" id="2103" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">CALL</span> {<br />    <span class="hljs-keyword">MATCH</span> (source:Airport)<span class="hljs-operator">-</span>[r:HAS_ROUTE]<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>(target:Airport)<br />    <span class="hljs-keyword">RETURN</span> source, target, r,<br />         <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> source.city <span class="hljs-operator">=</span> target.city <br />              <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;INTRACITY&#x27;</span> <span class="hljs-keyword">ELSE</span> <span class="hljs-string">&#x27;INTERCITY&#x27;</span> <span class="hljs-keyword">END</span> <span class="hljs-keyword">as</span> rel_type<br />    <span class="hljs-keyword">UNION</span><br />    <span class="hljs-keyword">MATCH</span> (source:Airport)<span class="hljs-operator">-</span>[r:IN_CITY]<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>(target:City)<br />    <span class="hljs-keyword">RETURN</span> source, target, r, type(r) <span class="hljs-keyword">as</span> rel_type<br />}<br /><span class="hljs-keyword">WITH</span> gds.alpha.graph.project(<span class="hljs-string">&#x27;airports-labels-precalculated&#x27;</span>, source, target,<br />  {sourceNodeLabels: labels(source),<br />   targetNodeLabels: labels(target)},<br />  {relationshipType: rel_type}) <span class="hljs-keyword">AS</span> graph<br /><span class="hljs-keyword">RETURN</span> graph.nodeCount <span class="hljs-keyword">AS</span> nodeCount, graph.relationshipCount <span class="hljs-keyword">AS</span> relationshipCount</span></pre><p name="c006" id="c006" class="graf graf--p graf-after--pre">Sometimes, we also want to project node or relationship properties.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="sql" name="711a" id="711a" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">MATCH</span> (source:Airport)<span class="hljs-operator">-</span>[r:HAS_ROUTE]<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>(target:Airport)<br /><span class="hljs-keyword">WITH</span> gds.alpha.graph.project(<span class="hljs-string">&#x27;airports-properties&#x27;</span>, source, target,<br />  {sourceNodeLabels: labels(source),<br />   targetNodeLabels: labels(target),<br />   sourceNodeProperties: {runways: source.runways},<br />   targetNodeProperties: {runways: target.runways}},<br />  {relationshipType: type(r), properties: {distance: r.distance}}) <span class="hljs-keyword">AS</span> graph<br /><span class="hljs-keyword">RETURN</span> graph.nodeCount <span class="hljs-keyword">AS</span> nodeCount, graph.relationshipCount <span class="hljs-keyword">AS</span> relationshipCount</span></pre><p name="3689" id="3689" class="graf graf--p graf-after--pre">The node or relationship properties are defined as a map object (dictionary or JSON object for Python or JS developers), where the key represents the projected property, and the value represents the projected value. This syntax allows us to project properties that are calculated during projection.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="sql" name="e581" id="e581" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">MATCH</span> (source:Airport)<span class="hljs-operator">-</span>[r:HAS_ROUTE]<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>(target:Airport)<br /><span class="hljs-keyword">WITH</span> gds.alpha.graph.project(<span class="hljs-string">&#x27;airports-properties-custom&#x27;</span>, source, target,<br />  {sourceNodeLabels: labels(source),<br />   targetNodeLabels: labels(target),<br />   sourceNodeProperties: {runways10: source.runways <span class="hljs-operator">*</span> <span class="hljs-number">10</span>},<br />   targetNodeProperties: {runways10: target.runways <span class="hljs-operator">*</span> <span class="hljs-number">10</span>}},<br />  {relationshipType: type(r),<br />  properties: {inverseDistance: <span class="hljs-number">1</span> <span class="hljs-operator">/</span> r.distance}}) <span class="hljs-keyword">AS</span> graph<br /><span class="hljs-keyword">RETURN</span> graph.nodeCount <span class="hljs-keyword">AS</span> nodeCount, graph.relationshipCount <span class="hljs-keyword">AS</span> relationshipCount</span></pre><p name="1e39" id="1e39" class="graf graf--p graf-after--pre">Again, we can use all the flexibility of Cypher to calculate any node or relationship properties. Similary as with node labels, we can also calculate the custom properties in the <code class="markup--code markup--p-code">MATCH</code> clause.</p><p name="b5f8" id="b5f8" class="graf graf--p graf-after--p">An important thing to note is that the current projection behavior is that the engine stores the node properties when it first encounters a node. However, on subsequent encounters of the same node, it ignores the node properties completely. Therefore, you have to be careful to calculate identical node properties for both source and target nodes. Otherwise, there may be discrepancies between what is projected and what you expect.</p><p name="a4d1" id="a4d1" class="graf graf--p graf-after--p">Some graph algorithms in the Neo4j Graph Data Science library expect undirected relationships. A relationship cannot be stored as undirected in the database and must be explicitly defined during graph projection.</p><p name="a437" id="a437" class="graf graf--p graf-after--p">Suppose you want to treat all projected relationships as undirected.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="sql" name="e2ef" id="e2ef" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">MATCH</span> (source:Airport)<span class="hljs-operator">-</span>[r:HAS_ROUTE]<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>(target:Airport)<br /><span class="hljs-keyword">WITH</span> gds.alpha.graph.project(<span class="hljs-string">&#x27;airports-undirected&#x27;</span>, source, target,<br />  {}, <span class="hljs-operator">/</span><span class="hljs-operator">/</span> nodeConfiguration<br />  {}, <span class="hljs-operator">/</span><span class="hljs-operator">/</span> relationshipConfiguration<br />  {undirectedRelationshipTypes: [<span class="hljs-string">&#x27;*&#x27;</span>]}<br />) <span class="hljs-keyword">AS</span> graph<br /><span class="hljs-keyword">RETURN</span> graph.nodeCount <span class="hljs-keyword">AS</span> nodeCount, graph.relationshipCount <span class="hljs-keyword">AS</span> relationshipCount</span></pre><p name="81fd" id="81fd" class="graf graf--p graf-after--pre">We can use the <strong class="markup--strong markup--p-strong">undirectedRelationshipType</strong> to specify which relationships should be projected as undirected. In practice, you can observe that the relationship count doubled when we projected an undirected graph.</p><p name="b5fd" id="b5fd" class="graf graf--p graf-after--p">Sometimes you might want to project a single relationship type as undirected while treating the other as directed.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="sql" name="ad39" id="ad39" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">CALL</span> {<br />    <span class="hljs-keyword">MATCH</span> (source:Airport)<span class="hljs-operator">-</span>[r:HAS_ROUTE]<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>(target:Airport)<br />    <span class="hljs-keyword">RETURN</span> source, target, r<br />    <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span><br />    <span class="hljs-keyword">MATCH</span> (source:Airport)<span class="hljs-operator">-</span>[r:IN_CITY]<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>(target:City)<br />    <span class="hljs-keyword">RETURN</span> source, target, r<br />}<br /><span class="hljs-keyword">WITH</span> gds.alpha.graph.project(<span class="hljs-string">&#x27;airports-undirected-specific&#x27;</span>, source, target,<br />  {},<br />  {relationshipType:type(r)},<br />  {undirectedRelationshipTypes: [<span class="hljs-string">&#x27;IN_CITY&#x27;</span>]}) <span class="hljs-keyword">AS</span> graph<br /><span class="hljs-keyword">RETURN</span> graph.nodeCount <span class="hljs-keyword">AS</span> nodeCount, graph.relationshipCount <span class="hljs-keyword">AS</span> relationshipCount</span></pre><p name="7203" id="7203" class="graf graf--p graf-after--pre">In this example, the <strong class="markup--strong markup--p-strong">HAS_ROUTE</strong> relationship is treated as directed, while the <strong class="markup--strong markup--p-strong">IN_CITY</strong> relationship is treated as undirected. When we want to specify specific relationship types to be treated as undirected, we must include the <strong class="markup--strong markup--p-strong">relationshipType</strong> parameter in the relationship configuration.</p><p name="0bbe" id="0bbe" class="graf graf--p graf-after--p">Lastly, we can also project virtual relationships. A virtual relationship is a relationship that is not stored in the database.</p><figure name="3d33" id="3d33" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*MebW8KiDlzapJgLMmc6sog.png" data-width="295" data-height="445" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*MebW8KiDlzapJgLMmc6sog.png"><figcaption class="imageCaption">Virtual relationship. Image by the author.</figcaption></figure><p name="c1b7" id="c1b7" class="graf graf--p graf-after--figure">Suppose you want to examine the cities based on their flight connections. The database doesn’t have flight relationships between cities. Instead of creating the relationships in the database, you can calculate them during graph projection.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="sql" name="dbbc" id="dbbc" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">MATCH</span> (sourceCity)<span class="hljs-operator">&lt;</span><span class="hljs-operator">-</span>[:IN_CITY]<span class="hljs-operator">-</span>(:Airport)<span class="hljs-operator">-</span>[:HAS_ROUTE]<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>(:Airport)<span class="hljs-operator">-</span>[:IN_CITY]<span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>(targetCity)<br /><span class="hljs-keyword">WITH</span> sourceCity, targetCity, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> countOfRoutes<br /><span class="hljs-keyword">WITH</span> gds.alpha.graph.project(<span class="hljs-string">&#x27;airports-virtual&#x27;</span>, sourceCity, targetCity,<br />  {},<br />  {relationshipType:<span class="hljs-string">&#x27;VIRTUAL_ROUTE&#x27;</span>},<br />  {}) <span class="hljs-keyword">AS</span> graph<br /><span class="hljs-keyword">RETURN</span> graph.nodeCount <span class="hljs-keyword">AS</span> nodeCount, graph.relationshipCount <span class="hljs-keyword">AS</span> relationshipCount</span></pre><p name="4934" id="4934" class="graf graf--p graf-after--pre">As you can observe, projecting virtual relationships is very easy with Cypher Aggregation projection. We have calculated the count of routes between various cities and added it as a relationship property in the projected graph.</p><p name="27ef" id="27ef" class="graf graf--p graf-after--p">Let’s calculate the most important cities based on the PageRank algorithm to finish off this blog post.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="sql" name="1b46" id="1b46" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">CALL</span> gds.pageRank.stream(<span class="hljs-string">&#x27;airports-virtual&#x27;</span>)<br />YIELD nodeId, score<br /><span class="hljs-keyword">RETURN</span> gds.util.asNode(nodeId).name <span class="hljs-keyword">AS</span> city, score<br /><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score <span class="hljs-keyword">DESC</span><br />LIMIT <span class="hljs-number">5</span></span></pre><p name="9523" id="9523" class="graf graf--p graf-after--pre"><em class="markup--em markup--p-em">Results</em></p><figure name="d4a3" id="d4a3" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tomasonjo/e991f4de5b11e42330de20843ab01eac.js"></script></figure><h4 name="fe8a" id="fe8a" class="graf graf--h4 graf-after--figure">Summary</h4><p name="6a79" id="6a79" class="graf graf--p graf-after--h4 graf--trailing">Cypher Aggregation is the newer option to project in-memory graphs in the Neo4j Graph Data Science library using Cypher statements. Specifically, it can be used to project undirected relationships, which is impossible with the older Cypher Projection. However, with the added flexibility of selecting and transforming graphs during projection comes a performance cost. Therefore, if you can, you should use Native Projection when possible for performance reasons. On the other hand, when you have specific use cases to project a particular subset of a graph, calculate custom properties or project virtual relationships, Cypher Aggregation is your friend.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@bratanic-tomaz" class="p-author h-card">Tomaz Bratanic</a> on <a href="https://medium.com/p/5d8c40c2670c"><time class="dt-published" datetime="2023-03-27T14:19:26.801Z">March 27, 2023</time></a>.</p><p><a href="https://medium.com/@bratanic-tomaz/how-to-use-cypher-aggregations-in-neo4j-graph-data-science-library-5d8c40c2670c" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on November 5, 2023.</p></footer></article></body></html>