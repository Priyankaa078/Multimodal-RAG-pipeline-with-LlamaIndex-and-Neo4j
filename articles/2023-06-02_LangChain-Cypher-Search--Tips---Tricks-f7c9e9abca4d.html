<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>LangChain Cypher Search: Tips &amp; Tricks</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">LangChain Cypher Search: Tips &amp; Tricks</h1>
</header>
<section data-field="subtitle" class="p-summary">
How to optimize prompts for Cypher statement generation to retrieve relevant information from Neo4j in your LLM applications
</section>
<section data-field="body" class="e-content">
<section name="1ab9" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="05e5" id="05e5" class="graf graf--h3 graf--leading graf--title">LangChain Cypher Search: Tips &amp; Tricks</h3><h4 name="585b" id="585b" class="graf graf--h4 graf-after--h3 graf--subtitle">How to optimize prompts for Cypher statement generation to retrieve relevant information from Neo4j in your LLM applications</h4><figure name="fc70" id="fc70" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*p4Tds251XusssNdhpK_p_A.png" data-width="1024" data-height="1024" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*p4Tds251XusssNdhpK_p_A.png"><figcaption class="imageCaption">Knowledge-graph chatbot as imagined by Midjourney.</figcaption></figure><p name="b7df" id="b7df" class="graf graf--p graf-after--figure">Last time, we looked at how to <a href="https://towardsdatascience.com/langchain-has-added-cypher-search-cb9d821120d5" data-href="https://towardsdatascience.com/langchain-has-added-cypher-search-cb9d821120d5" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">get started with Cypher Search in the LangChain library</a> and why you would want to use knowledge graphs in your LLM applications. In this blog post, we will continue to explore various use cases for <a href="https://neo4j.com/generativeai/?utm_campaign=gen-ai&amp;utm_content=medium&amp;utm_source=blog" data-href="https://neo4j.com/generativeai/?utm_campaign=gen-ai&amp;utm_content=medium&amp;utm_source=blog" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">integrating knowledge graphs into LLM</a> and LangChain applications. Along the way, you will learn how to improve prompts to produce better and more accurate Cypher statements.</p><p name="3001" id="3001" class="graf graf--p graf-after--p">Specifically, we will look at how to use the few-shot capabilities of LLMs by providing a couple of Cypher statement examples, which can be used to specify which Cypher statements the LLM should produce, what the results should look like, and more. Additionally, you will learn how you can integrate graph algorithms from the <a href="https://neo4j.com/docs/graph-data-science/current/" data-href="https://neo4j.com/docs/graph-data-science/current/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Neo4j Graph Data Science library</a> into your LangChain applications.</p><p name="093e" id="093e" class="graf graf--p graf-after--p">All the code is available on <a href="https://github.com/tomasonjo/blogs/blob/master/llm/langchain_neo4j_tips.ipynb" data-href="https://github.com/tomasonjo/blogs/blob/master/llm/langchain_neo4j_tips.ipynb" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">GitHub</a>.</p><h4 name="acd3" id="acd3" class="graf graf--h4 graf-after--p">Neo4j Environment Setup</h4><p name="27fd" id="27fd" class="graf graf--p graf-after--h4">In this blog post, we will be using the <a href="https://sandbox.neo4j.com/?usecase=twitch" data-href="https://sandbox.neo4j.com/?usecase=twitch" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Twitch dataset that is available in Neo4j Sandbox</a>.</p><figure name="1ba3" id="1ba3" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*el3TPeLEhwpWk0YSMSfJpg.png" data-width="1735" data-height="1136" src="https://cdn-images-1.medium.com/max/800/1*el3TPeLEhwpWk0YSMSfJpg.png"><figcaption class="imageCaption">Twitch dataset graph model. Image by the author.</figcaption></figure><p name="5351" id="5351" class="graf graf--p graf-after--figure">The Twitch social network composes of users. A small percentage of those users broadcast their gameplay or activities through live streams. In the graph model, users who do live streams are tagged with a secondary label Stream. Additional information about which teams they belong to, which games they play on stream, and in which language they present their content is present. We also know how many followers they had at the moment of scraping, the all-time historical view count, and when they created their accounts. The most relevant information for network analysis is knowing which users engaged in the streamer’s chat. You can distinguish if the user who chatted in the stream was a regular user (CHATTER relationship), a moderator of the stream (MODERATOR relationship), or a stream VIP.</p><p name="ae6a" id="ae6a" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">The network information was scraped between the 7th and the 10th of May 2021. Therefore, the dataset has outdated information.</em></p><h4 name="029a" id="029a" class="graf graf--h4 graf-after--p">Improving LangChain Cypher Search</h4><p name="bdcc" id="bdcc" class="graf graf--p graf-after--h4">First, we have to set up the LangChain Cypher search.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="d65f" id="d65f" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">import</span> os<br /><br /><span class="hljs-keyword">from</span> langchain.chat_models <span class="hljs-keyword">import</span> ChatOpenAI<br /><span class="hljs-keyword">from</span> langchain.chains <span class="hljs-keyword">import</span> GraphCypherQAChain<br /><span class="hljs-keyword">from</span> langchain.graphs <span class="hljs-keyword">import</span> Neo4jGraph<br /><br />os.environ[<span class="hljs-string">&#x27;OPENAI_API_KEY&#x27;</span>] = <span class="hljs-string">&quot;OPENAI_API_KEY&quot;</span><br /><br />graph = Neo4jGraph(<br />    url=<span class="hljs-string">&quot;bolt://44.212.12.199:7687&quot;</span>, <br />    username=<span class="hljs-string">&quot;neo4j&quot;</span>, <br />    password=<span class="hljs-string">&quot;buoy-warehouse-subordinates&quot;</span><br /><br /><br />chain = GraphCypherQAChain.from_llm(<br />    ChatOpenAI(temperature=<span class="hljs-number">0</span>), graph=graph, verbose=<span class="hljs-literal">True</span>,<br />)</span></pre><p name="6921" id="6921" class="graf graf--p graf-after--pre">I really love how easy it is to setup the Cypher Search in the LangChain library. You only need to define the Neo4j and OpenAI credentials, and you are good to go. Under the hood, the <code class="markup--code markup--p-code">graph</code> objects inspect the graph schema model and pass it to the <code class="markup--code markup--p-code">GraphCypherQAChain</code> to construct accurate Cypher statements.</p><p name="852a" id="852a" class="graf graf--p graf-after--p">Let’s begin with a simple question.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="dde1" id="dde1" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">chain.run(<span class="hljs-string">&quot;&quot;&quot;<br />Which fortnite streamer has the most followers?<br />&quot;&quot;&quot;</span>)</span></pre><p name="2c41" id="2c41" class="graf graf--p graf-after--pre"><em class="markup--em markup--p-em">Results</em></p><figure name="714d" id="714d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*k42KrsuOcDU38jq1FNJB1g.png" data-width="1045" data-height="187" src="https://cdn-images-1.medium.com/max/800/1*k42KrsuOcDU38jq1FNJB1g.png"><figcaption class="imageCaption">Generated answer. Image by the author.</figcaption></figure><p name="1fda" id="1fda" class="graf graf--p graf-after--figure">The Cypher chain constructed a relevant Cypher statement, used it to retrieve information from Neo4j, and provided the answer in natural language form.</p><p name="bda8" id="bda8" class="graf graf--p graf-after--p">Now let’s ask another question.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="39b9" id="39b9" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">chain.run(<span class="hljs-string">&quot;&quot;&quot;<br />Which italian streamer has the most followers?<br />&quot;&quot;&quot;</span>)</span></pre><p name="cc93" id="cc93" class="graf graf--p graf-after--pre"><em class="markup--em markup--p-em">Results</em></p><figure name="d6f0" id="d6f0" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*SsHLwFBwgtJumWe2Uo3Gbg.png" data-width="793" data-height="207" src="https://cdn-images-1.medium.com/max/800/1*SsHLwFBwgtJumWe2Uo3Gbg.png"><figcaption class="imageCaption">Generated answer. Image by the author.</figcaption></figure><p name="8ba9" id="8ba9" class="graf graf--p graf-after--figure">The generated Cypher statement looks valid, but unfortunately, we didn’t get any results. The problem is that the language values are stored as two-character country codes, and the LLM is unaware of that. There are a few options we have to overcome this problem. First, we can utilize the few-shot capabilities of LLMs by providing examples of Cypher statements, which the model then imitates when generating Cypher statements. To add example Cypher statements in the prompt, we have to update the Cypher generating prompt. You can take a look at the <a href="https://github.com/hwchase17/langchain/blob/master/langchain/chains/graph_qa/prompts.py" data-href="https://github.com/hwchase17/langchain/blob/master/langchain/chains/graph_qa/prompts.py" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">default prompt used to generate Cypher statements</a> to better understand the update we are going to do.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="0170" id="0170" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">from</span> langchain.prompts.prompt <span class="hljs-keyword">import</span> PromptTemplate<br /><br /><br />CYPHER_GENERATION_TEMPLATE = <span class="hljs-string">&quot;&quot;&quot;<br />Task:Generate Cypher statement to query a graph database.<br />Instructions:<br />Use only the provided relationship types and properties in the schema.<br />Do not use any other relationship types or properties that are not provided.<br />Schema:<br />{schema}<br />Cypher examples:<br /># How many streamers are from Norway?<br />MATCH (s:Stream)-[:HAS_LANGUAGE]-&gt;(:Language {{name: &#x27;no&#x27;}})<br />RETURN count(s) AS streamers<br /><br />Note: Do not include any explanations or apologies in your responses.<br />Do not respond to any questions that might ask anything else than for you to construct a Cypher statement.<br />Do not include any text except the generated Cypher statement.<br /><br />The question is:<br />{question}&quot;&quot;&quot;</span><br />CYPHER_GENERATION_PROMPT = PromptTemplate(<br />    input_variables=[<span class="hljs-string">&quot;schema&quot;</span>, <span class="hljs-string">&quot;question&quot;</span>], template=CYPHER_GENERATION_TEMPLATE<br />)</span></pre><p name="e885" id="e885" class="graf graf--p graf-after--pre">If you compare the new Cypher generating prompt to the default one, you can observe we only added the Cypher examples section. We added an example where the model could observe that the language values are given as two-character country codes. Now we can test the improved Cypher chain to answer the question about the most followed Italian streamers.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="9b11" id="9b11" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">chain_language_example = GraphCypherQAChain.from_llm(<br />    ChatOpenAI(temperature=<span class="hljs-number">0</span>), graph=graph, verbose=<span class="hljs-literal">True</span>,<br />    cypher_prompt=CYPHER_GENERATION_PROMPT<br />)<br /><br />chain_language_example.run(<span class="hljs-string">&quot;&quot;&quot;<br />Which italian streamer has the most followers?<br />&quot;&quot;&quot;</span>)</span></pre><p name="795a" id="795a" class="graf graf--p graf-after--pre"><em class="markup--em markup--p-em">Results</em></p><figure name="f5ba" id="f5ba" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*-bYy64kMVjpbHBrSFLWWWg.png" data-width="946" data-height="206" src="https://cdn-images-1.medium.com/max/800/1*-bYy64kMVjpbHBrSFLWWWg.png"><figcaption class="imageCaption">Generated answer. Image by the author.</figcaption></figure><p name="3db6" id="3db6" class="graf graf--p graf-after--figure">The model is now aware that the languages are given as two-character country codes and can now accurately answer questions that use the language information.</p><p name="05ad" id="05ad" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">Another way we could solve this problem is to give a few example values of each property when defining the graph schema information. The solution would be generic and probably quite useful. Perhaps time to add another PR to the LangChain library :)</em></p><h4 name="611c" id="611c" class="graf graf--h4 graf-after--p">Using graph algorithms to answer questions</h4><p name="b89d" id="b89d" class="graf graf--p graf-after--h4">In the previous blog post, we looked at how integrating graph databases into LLM applications can answer questions like how entities are connected by finding the shortest or other paths between them. Today we will look at other use cases where graph databases can be used in LLM applications that other databases struggle with, specifically how we can use graph algorithms like PageRank to provide relevant answers. For example, we can use personalized PageRank to provide recommendations to an end user at query time.</p><p name="78d3" id="78d3" class="graf graf--p graf-after--p">Take a look at the following example:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="6666" id="6666" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">chain_language_example.run(<span class="hljs-string">&quot;&quot;&quot;<br />Which streamers should also I watch if I like pokimane?<br />&quot;&quot;&quot;</span>)</span></pre><p name="1f38" id="1f38" class="graf graf--p graf-after--pre"><em class="markup--em markup--p-em">Results</em></p><figure name="dff8" id="dff8" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*HysYwMGQOnV436ZFyVwIgA.png" data-width="826" data-height="216" src="https://cdn-images-1.medium.com/max/800/1*HysYwMGQOnV436ZFyVwIgA.png"><figcaption class="imageCaption">Generated answer. Image by the author.</figcaption></figure><p name="0820" id="0820" class="graf graf--p graf-after--figure">Interestingly, every time we rerun this question, the model will generate a different Cypher statement. However, one thing is consistent. For some reason, every time the League of Legends is somehow included in the query.</p><p name="e548" id="e548" class="graf graf--p graf-after--p">A bit more worrying fact is that the LLM model provided recommendations even though it wasn’t provided with any suggestions in the prompt context. It’s known that <strong class="markup--strong markup--p-strong">gpt-3.5-turbo</strong> sometimes doesn’t follow the rules, especially if you do not repeat them more than once.</p><figure name="333f" id="333f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*wDLrBRttfRWw2bl6c5Eszg.jpeg" data-width="400" data-height="400" src="https://cdn-images-1.medium.com/max/800/1*wDLrBRttfRWw2bl6c5Eszg.jpeg"><figcaption class="imageCaption">GPT-3.5-turbo being itself.</figcaption></figure><p name="7880" id="7880" class="graf graf--p graf-after--figure">Repeating the instruction three times can help gpt-3.5-turbo solve this problem. However, by repeating instructions, you are increasing the token count and, consequently, the cost of Cypher generation. Therefore, it would take some prompt engineering to get the best results using the lowest count of tokens.</p><p name="53c1" id="53c1" class="graf graf--p graf-after--p">On the other hand, <strong class="markup--strong markup--p-strong">GPT-4 </strong>is far better at following instructions.</p><figure name="38cb" id="38cb" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*9UsJnjPG1GtTQ3MrW_fNlQ.png" data-width="813" data-height="212" src="https://cdn-images-1.medium.com/max/800/1*9UsJnjPG1GtTQ3MrW_fNlQ.png"><figcaption class="imageCaption">GPT-4 doesn’t add any information that is not available in the context. Image by the author.</figcaption></figure><p name="5e93" id="5e93" class="graf graf--p graf-after--figure">GPT-4 didn’t add any information from its internal knowledge. However, its generated Cypher statement was still relatively bad. Again, we can solve this problem by providing Cypher examples in the LLM prompt.</p><p name="fd3b" id="fd3b" class="graf graf--p graf-after--p">As mentioned, we will use Personalized PageRank to provide stream recommendations. But first, we need to project the in-memory graph and run the Node Similarity algorithm to prepare the graph to be able to give recommendations. Look at my <a href="https://towardsdatascience.com/twitchverse-a-network-analysis-of-twitch-universe-using-neo4j-graph-data-science-d7218b4453ff" data-href="https://towardsdatascience.com/twitchverse-a-network-analysis-of-twitch-universe-using-neo4j-graph-data-science-d7218b4453ff" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">previous blog post</a> to learn more about how graph algorithms can be used to analyze the Twitch network.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="bc2f" id="bc2f" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment"># Project in-memory graph</span><br />graph.query(<span class="hljs-string">&quot;&quot;&quot;<br />CALL gds.graph.project(&#x27;shared-audience&#x27;,<br />  [&#x27;User&#x27;, &#x27;Stream&#x27;],<br />  {CHATTER: {orientation:&#x27;REVERSE&#x27;}})<br />&quot;&quot;&quot;</span>)<br /><br /><span class="hljs-comment"># Run node similarity algorithm</span><br />graph.query(<span class="hljs-string">&quot;&quot;&quot;<br />CALL gds.nodeSimilarity.mutate(&#x27;shared-audience&#x27;,<br /> {similarityMetric: &#x27;Jaccard&#x27;,similarityCutoff:0.05, topK:10, sudo:true,<br />     mutateProperty:&#x27;score&#x27;, mutateRelationshipType:&#x27;SHARED_AUDIENCE&#x27;})<br />&quot;&quot;&quot;</span>)</span></pre><p name="3e0f" id="3e0f" class="graf graf--p graf-after--pre">The node similarity algorithm will take about 30 seconds to complete as the database has almost five million users. The Cypher statement to provide recommendations using Personalized PageRank is the following:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="sql" name="e3df" id="e3df" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">MATCH</span> (s:Stream)<br /><span class="hljs-keyword">WHERE</span> s.name <span class="hljs-operator">=</span> &quot;kimdoe&quot;<br /><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">collect</span>(s) <span class="hljs-keyword">AS</span> sourceNodes<br /><span class="hljs-keyword">CALL</span> gds.pageRank.stream(&quot;shared-audience&quot;, <br />  {sourceNodes:sourceNodes, relationshipTypes:[<span class="hljs-string">&#x27;SHARED_AUDIENCE&#x27;</span>], <br />    nodeLabels:[<span class="hljs-string">&#x27;Stream&#x27;</span>]})<br />YIELD nodeId, score<br /><span class="hljs-keyword">WITH</span> gds.util.asNode(nodeId) <span class="hljs-keyword">AS</span> node, score<br /><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> node <span class="hljs-keyword">in</span> sourceNodes<br /><span class="hljs-keyword">RETURN</span> node.name <span class="hljs-keyword">AS</span> streamer, score<br /><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score <span class="hljs-keyword">DESC</span> LIMIT <span class="hljs-number">3</span></span></pre><p name="b786" id="b786" class="graf graf--p graf-after--pre">The OpenAI LLMs could be better at using the Graph Data Science library as their knowledge cutoff is September 2021, and version 2 of the Graph Data Science library was released in April 2022. Therefore, we need to provide another example in the prompt to show the LLM show to use Personalized PageRank to give recommendations.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="d515" id="d515" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">CYPHER_RECOMMENDATION_TEMPLATE = <span class="hljs-string">&quot;&quot;&quot;Task:Generate Cypher statement to query a graph database.<br />Instructions:<br />Use only the provided relationship types and properties in the schema.<br />Do not use any other relationship types or properties that are not provided.<br />Schema:<br />{schema}<br />Cypher examples:<br /># How many streamers are from Norway?<br />MATCH (s:Stream)-[:HAS_LANGUAGE]-&gt;(:Language {{name: &#x27;no&#x27;}})<br />RETURN count(s) AS streamers<br /># Which streamers do you recommend if I like kimdoe?<br />MATCH (s:Stream)<br />WHERE s.name = &quot;kimdoe&quot;<br />WITH collect(s) AS sourceNodes<br />CALL gds.pageRank.stream(&quot;shared-audience&quot;, <br />  {sourceNodes:sourceNodes, relationshipTypes:[&#x27;SHARED_AUDIENCE&#x27;], <br />    nodeLabels:[&#x27;Stream&#x27;]})<br />YIELD nodeId, score<br />WITH gds.util.asNode(nodeId) AS node, score<br />WHERE NOT node in sourceNodes<br />RETURN node.name AS streamer, score<br />ORDER BY score DESC LIMIT 3<br /><br />Note: Do not include any explanations or apologies in your responses.<br />Do not respond to any questions that might ask anything else than for you to construct a Cypher statement.<br />Do not include any text except the generated Cypher statement.<br /><br />The question is:<br />{question}&quot;&quot;&quot;</span><br />CYPHER_RECOMMENDATION_PROMPT = PromptTemplate(<br />    input_variables=[<span class="hljs-string">&quot;schema&quot;</span>, <span class="hljs-string">&quot;question&quot;</span>], template=CYPHER_RECOMMENDATION_TEMPLATE<br />)</span></pre><p name="46e8" id="46e8" class="graf graf--p graf-after--pre">We can now test the Personalized PageRank recommendations.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="5c31" id="5c31" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">chain_recommendation_example = GraphCypherQAChain.from_llm(<br />    ChatOpenAI(temperature=<span class="hljs-number">0</span>, model_name=<span class="hljs-string">&#x27;gpt-4&#x27;</span>), graph=graph, verbose=<span class="hljs-literal">True</span>,<br />    cypher_prompt=CYPHER_RECOMMENDATION_PROMPT, <br />)<br /><br />chain_recommendation_example.run(<span class="hljs-string">&quot;&quot;&quot;<br />Which streamers do you recommend if I like pokimane?<br />&quot;&quot;&quot;</span>)</span></pre><p name="17f7" id="17f7" class="graf graf--p graf-after--pre"><em class="markup--em markup--p-em">Results</em></p><figure name="101a" id="101a" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*tF5XKmssMkmzCXS1-x7DCw.png" data-width="809" data-height="346" src="https://cdn-images-1.medium.com/max/800/1*tF5XKmssMkmzCXS1-x7DCw.png"><figcaption class="imageCaption">Generated answer. Image by the author.</figcaption></figure><p name="910b" id="910b" class="graf graf--p graf-after--figure">Unfortunately, here, we have to use the GPT-4 model as the gpt-3.5-turbo is stubborn and doesn’t want to imitate the complex Personalized PageRank example.</p><p name="0046" id="0046" class="graf graf--p graf-after--p">We can also test if the GPT-4 model will decide to generalize the Personalized PageRank recommendation in other use cases.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="0efe" id="0efe" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">chain_recommendation_example.run(<span class="hljs-string">&quot;&quot;&quot;<br />Which streamers do you recommend to watch if I like Chess games?<br />&quot;&quot;&quot;</span>)</span></pre><p name="2eac" id="2eac" class="graf graf--p graf-after--pre"><em class="markup--em markup--p-em">Results</em></p><figure name="024d" id="024d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*J_ac1Rwz-IZswcy2JaG6gQ.png" data-width="804" data-height="202" src="https://cdn-images-1.medium.com/max/800/1*J_ac1Rwz-IZswcy2JaG6gQ.png"><figcaption class="imageCaption">Generated answer. Image by the author.</figcaption></figure><p name="d990" id="d990" class="graf graf--p graf-after--figure">The LLM decided to take a more straightforward route to provide recommendations and simply returned the three chess players with the highest follower count. We can’t really blame it for choosing this option.</p><p name="bcb5" id="bcb5" class="graf graf--p graf-after--p">However, LLMs are quite good at listening to hints:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="5d15" id="5d15" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">chain_recommendation_example.run(<span class="hljs-string">&quot;&quot;&quot;<br />Which streamers do you recommend to watch if I like Chess games?<br />Use Personalized PageRank to provide recommendations.<br />Do not exclude sourceNodes in the answer<br />&quot;&quot;&quot;</span>)</span></pre><p name="498c" id="498c" class="graf graf--p graf-after--pre">Results</p><figure name="b97e" id="b97e" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*cjq4ownCvUJmpoOnBTk0Jw.png" data-width="805" data-height="331" src="https://cdn-images-1.medium.com/max/800/1*cjq4ownCvUJmpoOnBTk0Jw.png"><figcaption class="imageCaption">Generated answer. Image by the author.</figcaption></figure><h4 name="9d60" id="9d60" class="graf graf--h4 graf-after--figure">Summary</h4><p name="3ef2" id="3ef2" class="graf graf--p graf-after--h4">In this blog post, we expanded on using knowledge graphs in LangChain applications, focusing on improving prompts for better Cypher statements. The main opportunity to improve the Cypher generation accuracy is to use the few-shot capabilities of LLMs, offering Cypher statement examples that dictate the type of statements an LLM should produce. Sometimes, the LLM model doesn’t correctly guess the property values, while other times, it doesn’t provide the Cypher statements we would like it to generate. Additionally, we have looked at how we can use graph algorithms like Personalized PageRank in LLM applications to provide better and more relevant answers.</p><p name="09d9" id="09d9" class="graf graf--p graf-after--p graf--trailing">As always, the code is available on <a href="https://github.com/tomasonjo/blogs/blob/master/llm/langchain_neo4j_tips.ipynb" data-href="https://github.com/tomasonjo/blogs/blob/master/llm/langchain_neo4j_tips.ipynb" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">GitHub</a>.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@bratanic-tomaz" class="p-author h-card">Tomaz Bratanic</a> on <a href="https://medium.com/p/f7c9e9abca4d"><time class="dt-published" datetime="2023-06-02T15:51:24.060Z">June 2, 2023</time></a>.</p><p><a href="https://medium.com/@bratanic-tomaz/langchain-cypher-search-tips-tricks-f7c9e9abca4d" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on November 5, 2023.</p></footer></article></body></html>