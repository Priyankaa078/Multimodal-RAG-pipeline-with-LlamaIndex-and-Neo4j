<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>How Cypher changed in Neo4j v5</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">How Cypher changed in Neo4j v5</h1>
</header>
<section data-field="subtitle" class="p-summary">
What’s new and what’s been deprecated in Cypher in the latest release of Neo4j
</section>
<section data-field="body" class="e-content">
<section name="a64d" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="63e5" id="63e5" class="graf graf--h3 graf--leading graf--title">How Cypher changed in Neo4j v5</h3><h4 name="ffce" id="ffce" class="graf graf--h4 graf-after--h3 graf--subtitle">What’s new and what’s been deprecated in Cypher in the latest release of Neo4j</h4><p name="6e0d" id="6e0d" class="graf graf--p graf-after--h4">A couple of weeks ago, Neo4j 5 was released. If you are like me and have ignored all the deprecation warnings during the later Neo4j 4 version, you might have to update your Cypher queries to work with the latest Neo4j version. Luckily, there are no significant differences in the new Cypher syntax, so the update process should not be difficult. However, I have decided to write this blog post to help you transition. Additionally, I will introduce some of the new Cypher syntax that could simplify your queries.</p><p name="f730" id="f730" class="graf graf--p graf-after--p">The Cypher examples of this blog post are available as a <a href="https://github.com/tomasonjo/blogs/blob/master/dune/Cypher_v5.ipynb" data-href="https://github.com/tomasonjo/blogs/blob/master/dune/Cypher_v5.ipynb" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Jupyter Notebook on GitHub</a>.</p><h4 name="2df8" id="2df8" class="graf graf--h4 graf-after--p">Neo4j environment setup</h4><p name="09a4" id="09a4" class="graf graf--p graf-after--h4">You will need to set up a Neo4j environment to follow the code examples in this post. As always, you can set up a local environment by using the <a href="https://neo4j.com/download/" data-href="https://neo4j.com/download/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Neo4j Desktop</a> application. On the other hand, you can use a free cloud instance available as <a href="https://neo4j.com/cloud/platform/aura-graph-database/" data-href="https://neo4j.com/cloud/platform/aura-graph-database/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Neo4j Aura</a>. If you choose the Neo4j Aura route, use the free forever instance and start a blank project that doesn’t come with a pre-populated graph.</p><p name="a93e" id="a93e" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">p.s. The free forever Neo4j Aura instance does not offer GDS support. Since this is a Cypher focused blog post, you won’t be using any algorithms from the GDS library.</em></p><h4 name="698b" id="698b" class="graf graf--h4 graf-after--p">Dataset</h4><p name="6c75" id="6c75" class="graf graf--p graf-after--h4">I have a special place in my heart for fantasy or superhero datasets. This time, I found a dataset describing characters in the Dune series.</p><div name="22bb" id="22bb" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://www.kaggle.com/datasets/bac3917/frank-herberts-dune-characters" data-href="https://www.kaggle.com/datasets/bac3917/frank-herberts-dune-characters" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://www.kaggle.com/datasets/bac3917/frank-herberts-dune-characters"><strong class="markup--strong markup--mixtapeEmbed-strong">Frank Herbert&#39;s DUNE Characters</strong><br><em class="markup--em markup--mixtapeEmbed-em">Social networks in a fantastic world.... help build the dataset!</em>www.kaggle.com</a><a href="https://www.kaggle.com/datasets/bac3917/frank-herberts-dune-characters" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="df6dbfad9f6cb806d9f5862fa57ca526" data-thumbnail-img-id="0*AmR_WsgN2bC0pN7j" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*AmR_WsgN2bC0pN7j);"></a></div><p name="ea2e" id="ea2e" class="graf graf--p graf-after--mixtapeEmbed">The Dune dataset is available on Kaggle under the CC0 license. To make it easier for you, I have copied the dataset to a GitHub repository, so you don’t have to download the dataset and can easily import it in either your local or cloud instance of Neo4j. Additionally, I have renamed the relationship types Parent-Child and Other Family to Family, and removed the Unknown relation.</p><h4 name="c327" id="c327" class="graf graf--h4 graf-after--p">Graph Model</h4><figure name="71be" id="71be" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*lZ0mrqgy8bmccrM5dyiSgQ.png" data-width="381" data-height="401" src="https://cdn-images-1.medium.com/max/800/1*lZ0mrqgy8bmccrM5dyiSgQ.png"><figcaption class="imageCaption">Dune graph model. Image by the author.</figcaption></figure><p name="5b7c" id="5b7c" class="graf graf--p graf-after--figure">The graph model revolves around characters. The character nodes have multiple properties like the name, Culture, and when they were Born or Died. Additionally, their house allegiance is represented as a secondary node label. The main idea for using the secondary node label instead of a separate node is to demonstrate the new node label filtering options in Cypher. There are four types of relationships between characters:</p><ul class="postList"><li name="c949" id="c949" class="graf graf--li graf-after--p">ALLIES</li><li name="10bb" id="10bb" class="graf graf--li graf-after--li">ENEMIES,</li><li name="93c9" id="93c9" class="graf graf--li graf-after--li">FAMILY</li><li name="0cf1" id="0cf1" class="graf graf--li graf-after--li">MARRIAGE</li></ul><h4 name="943a" id="943a" class="graf graf--h4 graf-after--li">Dataset import</h4><p name="d4f5" id="d4f5" class="graf graf--p graf-after--h4">As with most imports, you first want to define unique constraints in Neo4j. Unique constraints ensure that a given property is unique for every node with a particular label.</p><p name="b7e1" id="b7e1" class="graf graf--p graf-after--p">The syntax for defining unique constraints has slightly changed in Neo4j v5.</p><figure name="b4a1" id="b4a1" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*3yWCxJ0ZpB6Z1Ef1IT6RUg.png" data-width="665" data-height="241" src="https://cdn-images-1.medium.com/max/800/1*3yWCxJ0ZpB6Z1Ef1IT6RUg.png"><figcaption class="imageCaption">Syntax change for UNIQUE CONSTRAINTS. Image by the author.</figcaption></figure><p name="b068" id="b068" class="graf graf--p graf-after--figure">The new syntax for unique constraints has two keywords replaced. The <strong class="markup--strong markup--p-strong">ON</strong> keyword is replaced with <strong class="markup--strong markup--p-strong">FOR</strong>, while the <strong class="markup--strong markup--p-strong">ASSERT</strong> is changed to <strong class="markup--strong markup--p-strong">REQUIRE</strong>.</p><p name="9947" id="9947" class="graf graf--p graf-after--p">The following Cypher statements define the unique constraint for <strong class="markup--strong markup--p-strong">name</strong> property of <strong class="markup--strong markup--p-strong">Character</strong> nodes.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="da8a" id="da8a" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">CONSTRAINT</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-keyword">FOR</span> (c:<span class="hljs-type">Character</span>) REQUIRE c.name <span class="hljs-keyword">IS</span> <span class="hljs-keyword">UNIQUE</span>;</span></pre><p name="6475" id="6475" class="graf graf--p graf-after--pre">Next, you need to import the CSV file. Even though the Dune CSV file has only 1000 rows, you will pretend you are dealing with a large CSV file with many thousands of rows. Therefore, you want to use batch import into multiple transactions. As <strong class="markup--strong markup--p-strong">USING PERIODIC COMMIT</strong> clause has been deprecated in Neo4j v5, you need to use the new batched transaction syntax.</p><figure name="c066" id="c066" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*jbSx2U9zCIv1mzSZv8OAyg.png" data-width="835" data-height="285" src="https://cdn-images-1.medium.com/max/800/1*jbSx2U9zCIv1mzSZv8OAyg.png"><figcaption class="imageCaption">Syntax change for importing large CSV files. Image by the author.</figcaption></figure><p name="0298" id="0298" class="graf graf--p graf-after--figure">The subqueries were already introduced in Neo4j v4 but have taken on a more prominent role in v5. The subqueries are instantiated with a <strong class="markup--strong markup--p-strong">CALL</strong> clause and wrapped with curly brackets <strong class="markup--strong markup--p-strong">{}</strong>. They are great for various functionalities like <a href="https://neo4j.com/developer/kb/post-union-processing/" data-href="https://neo4j.com/developer/kb/post-union-processing/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">post-union processing</a>, <a href="https://neo4j.com/developer/kb/limiting-match-results-per-row/" data-href="https://neo4j.com/developer/kb/limiting-match-results-per-row/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">limiting results per row</a>, and <a href="https://neo4j.com/developer/kb/conditional-cypher-execution/" data-href="https://neo4j.com/developer/kb/conditional-cypher-execution/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">conditional execution</a>. Additionally, the Cypher subqueries are now the only native Cypher syntax (excluding APOC) to batch a single Cypher statement into multiple transactions. In order to specify that the Cypher subquery should be split into multiple transactions, you need to add <strong class="markup--strong markup--p-strong">IN</strong> <strong class="markup--strong markup--p-strong">TRANSACTIONS OF x ROWS</strong>, where the x represents the number of rows for each batch.</p><p name="b4d0" id="b4d0" class="graf graf--p graf-after--p">The following Cypher statement contains two nested subqueries. The top-level subquery is used to batch the import into a new transaction for every 10 rows. On the other hand, you use the nested Cypher subquery as a conditional execution feature.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="sql" name="d95a" id="d95a" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">LOAD CSV <span class="hljs-keyword">WITH</span> HEADERS <span class="hljs-keyword">FROM</span> &quot;https://bit.ly/3kbU21V&quot; <span class="hljs-keyword">AS</span> <span class="hljs-type">row</span><br /><span class="hljs-keyword">CALL</span> {<br />  <span class="hljs-keyword">WITH</span> <span class="hljs-type">row</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span> Explicit import <span class="hljs-keyword">of</span> variables<br />  <span class="hljs-keyword">MERGE</span> (c:<span class="hljs-type">Character</span> {name:row.Character})<br />  <span class="hljs-keyword">SET</span> c <span class="hljs-operator">+</span><span class="hljs-operator">=</span> apoc.map.clean(<span class="hljs-type">row</span>, <br />     [&quot;name&quot;, &quot;Detail&quot;, &quot;to&quot;, &quot;relationship_type&quot;, &quot;House_Allegiance&quot;], [])<br />  <span class="hljs-keyword">WITH</span> c, <span class="hljs-type">row</span><br />  <span class="hljs-keyword">CALL</span> apoc.create.addLabels(c, [row.House_Allegiance]) YIELD node<br />  <span class="hljs-operator">/</span><span class="hljs-operator">/</span> nested subquery <span class="hljs-keyword">for</span> conditional execution<br />  <span class="hljs-keyword">CALL</span> {<br />    <span class="hljs-keyword">WITH</span> <span class="hljs-type">row</span>, c <span class="hljs-operator">/</span><span class="hljs-operator">/</span> Explicit import <span class="hljs-keyword">of</span> variables<br />    <span class="hljs-keyword">WITH</span> <span class="hljs-type">row</span>, c<br />    <span class="hljs-keyword">WHERE</span> row.to <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br />    <span class="hljs-keyword">MERGE</span> (c1:<span class="hljs-type">Character</span> {name: row.to})<br />    <span class="hljs-keyword">WITH</span> <span class="hljs-type">row</span>, c, c1<br />    <span class="hljs-keyword">CALL</span> apoc.merge.relationship(c, toUpper(row.relationship_type), {}, {}, c1)<br />    YIELD rel<br />    <span class="hljs-keyword">RETURN</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> count<br />  }<br />  <span class="hljs-keyword">RETURN</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> finalCount<br />} <span class="hljs-keyword">IN</span> TRANSACTIONS <span class="hljs-keyword">OF</span> <span class="hljs-number">10</span> <span class="hljs-keyword">ROWS</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-keyword">Define</span> batched transaction <span class="hljs-keyword">for</span> <span class="hljs-keyword">every</span> <span class="hljs-number">10</span> <span class="hljs-keyword">rows</span><br /><span class="hljs-keyword">RETURN</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)</span></pre><p name="a869" id="a869" class="graf graf--p graf-after--pre">The import query is a bit more complicated because I wanted to do the import in a single Cypher statement. It starts with the <strong class="markup--strong markup--p-strong">LOAD CSV</strong> clause that you might have seen before. In order to batch the import into multiple transactions, you need to initiate a Cypher subquery with the <strong class="markup--strong markup--p-strong">CALL</strong> clause. The top-level subquery ends with the <strong class="markup--strong markup--p-strong">IN TRANSACTIONS OF x ROWS</strong> clause, which specifies the transaction batching.</p><p name="1f21" id="1f21" class="graf graf--p graf-after--p">If you want to use any variable in the Cypher statement, you must explicitly import it with the <strong class="markup--strong markup--p-strong">WITH</strong> clause. First, the top-level subquery import the <strong class="markup--strong markup--p-strong">row</strong> variable from the outer query. Next, it merges the Character node and sets a couple of properties. Since adding dynamic secondary labels is not supported in plain Cypher, you can use the APOC’s procedure.</p><p name="013d" id="013d" class="graf graf--p graf-after--p">Some of the Dune characters have additional relationships defined in the <strong class="markup--strong markup--p-strong">to</strong> and <strong class="markup--strong markup--p-strong">relationship_type</strong> columns of the CSV. On the other hand, the <strong class="markup--strong markup--p-strong">to</strong> and <strong class="markup--strong markup--p-strong">relationship_type</strong> columns are empty for several rows. The <a href="https://neo4j.com/developer/kb/conditional-cypher-execution/#_using_foreach_for_write_only_cypher" data-href="https://neo4j.com/developer/kb/conditional-cypher-execution/#_using_foreach_for_write_only_cypher" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">FOREACH conditional execution trick</a> was my go-to option for the better part of my blog post. However, as the theme of this blog post are Cypher subqueries, I have decided to show you how to use Cypher subqueries for conditional execution. First, with the nested Cypher subquery, you need to import both the <strong class="markup--strong markup--p-strong">row</strong> and the <strong class="markup--strong markup--p-strong">c</strong> variables. Next, you need to filter out only rows where the <strong class="markup--strong markup--p-strong">to</strong> column is not null. However, you cannot filter variables in the same <strong class="markup--strong markup--p-strong">WITH</strong> clause used to import them. Therefore, you need to add a second <strong class="markup--strong markup--p-strong">WITH</strong> clause to filter rows. Lastly, you use the APOC’s procedure for merging relationships, as the plain Cypher syntax does not support creating properties with dynamic relationship types.</p><p name="665e" id="665e" class="graf graf--p graf-after--p">You can check out the <a href="https://neo4j.com/docs/cypher-manual/current/clauses/call-subquery" data-href="https://neo4j.com/docs/cypher-manual/current/clauses/call-subquery" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">documentation</a> if this example was a bit too packed for you.</p><h4 name="dd28" id="dd28" class="graf graf--h4 graf-after--p">New inline filtering options</h4><p name="3f1a" id="3f1a" class="graf graf--p graf-after--h4">There are many new options available for inline filtering in Neo4j v5. So what exactly is inline filtering? Essentially, it is the ability to filter a graph pattern directly in the <strong class="markup--strong markup--p-strong">MATCH</strong> clause.</p><p name="ec6f" id="ec6f" class="graf graf--p graf-after--p">You will begin by learning the new syntax for filtering node labels. In Neo4j v5, the following logical expressions were introduced to allow more flexible node filtering.</p><ul class="postList"><li name="6a63" id="6a63" class="graf graf--li graf-after--p">&amp; — AND expression</li><li name="ed32" id="ed32" class="graf graf--li graf-after--li">| — OR expression</li><li name="0ce5" id="0ce5" class="graf graf--li graf-after--li">! — NOT expression</li></ul><p name="7fe8" id="7fe8" class="graf graf--p graf-after--li">For example, if you want to match all nodes with either the <strong class="markup--strong markup--p-strong">Fremen</strong> or <strong class="markup--strong markup--p-strong">Harkonnen</strong> label, you can use the <strong class="markup--strong markup--p-strong">|</strong> expression.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="sql" name="bad6" id="bad6" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">MATCH</span> (c:Fremen<span class="hljs-operator">|</span>Harkonnen)<br /><span class="hljs-keyword">RETURN</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)</span></pre><p name="2d01" id="2d01" class="graf graf--p graf-after--pre">On the other hand, if you need to find all nodes with both the <strong class="markup--strong markup--p-strong">Character</strong> and <strong class="markup--strong markup--p-strong">Harkonnen</strong> labels, you can use the <strong class="markup--strong markup--p-strong">&amp;</strong> expression.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="c81b" id="c81b" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">MATCH</span> (c:<span class="hljs-type">Character</span><span class="hljs-operator">&amp;</span>Harkonnen)<br /><span class="hljs-keyword">RETURN</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)</span></pre><p name="de2e" id="de2e" class="graf graf--p graf-after--pre">The <strong class="markup--strong markup--p-strong">!</strong> expression allows you to negate node labels. For example, say that you want to match all nodes with <strong class="markup--strong markup--p-strong">the Character</strong> label but don’t have the <strong class="markup--strong markup--p-strong">Harkonnen</strong> label.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="162e" id="162e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">MATCH</span> (c:<span class="hljs-type">Character</span><span class="hljs-operator">&amp;</span><span class="hljs-operator">!</span>Harkonnen)<br /><span class="hljs-keyword">RETURN</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)</span></pre><p name="6c16" id="6c16" class="graf graf--p graf-after--pre">The Cypher now also supports nested expressions for filtering node labels. For example, the following Cypher statement matches all nodes that don’t have the <strong class="markup--strong markup--p-strong">Fremen</strong> or the <strong class="markup--strong markup--p-strong">Harkonnen</strong> labels.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="sql" name="d548" id="d548" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">MATCH</span> (c:<span class="hljs-operator">!</span>(Fremen<span class="hljs-operator">|</span>Harkonnen))<br /><span class="hljs-keyword">RETURN</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)</span></pre><p name="ebed" id="ebed" class="graf graf--p graf-after--pre">The expressions are nested using the parenthesis ().</p><p name="416d" id="416d" class="graf graf--p graf-after--p">Another feature added to Cypher is the option to include the <strong class="markup--strong markup--p-strong">WHERE</strong> clause within the <strong class="markup--strong markup--p-strong">MATCH</strong> clause. This allows you to apply all the flexibility of the Cypher filtering by node properties directly within the MATCH statement.</p><p name="ac83" id="ac83" class="graf graf--p graf-after--p">For example, the following Cypher statement matches all characters where the <strong class="markup--strong markup--p-strong">Culture</strong> property starts with <strong class="markup--strong markup--p-strong">Z</strong> and the <strong class="markup--strong markup--p-strong">Died</strong> property is <strong class="markup--strong markup--p-strong">not null</strong>.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="c759" id="c759" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">MATCH</span> (c:<span class="hljs-type">Character</span> <span class="hljs-keyword">WHERE</span> c.Culture STARTS <span class="hljs-keyword">WITH</span> &quot;Z&quot; <span class="hljs-keyword">AND</span> c.Died <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>)<br /><span class="hljs-keyword">RETURN</span> c.name <span class="hljs-keyword">AS</span> <span class="hljs-type">character</span></span></pre><p name="a11a" id="a11a" class="graf graf--p graf-after--pre">The same logical expressions used to filter nodes can also be used when filtering relationship types. For example, the <strong class="markup--strong markup--p-strong">|</strong> expression, which expresses the logical OR, has been in Cypher for quite some time.</p><p name="9255" id="9255" class="graf graf--p graf-after--p">The following Cypher statement matches all <strong class="markup--strong markup--p-strong">Character</strong> nodes with the <strong class="markup--strong markup--p-strong">Culture</strong> property values of <strong class="markup--strong markup--p-strong">Bene Gesserit</strong> and expands their <strong class="markup--strong markup--p-strong">ALLIES</strong> or <strong class="markup--strong markup--p-strong">FAMILY</strong> relationships.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="d7b6" id="d7b6" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">MATCH</span> p<span class="hljs-operator">=</span>(c:<span class="hljs-type">Character</span> <span class="hljs-keyword">WHERE</span> c.Culture <span class="hljs-operator">=</span> &quot;Bene Gesserit&quot;)<span class="hljs-operator">-</span>[r:ALLIES<span class="hljs-operator">|</span>FAMILY]<span class="hljs-operator">-</span>()<br /><span class="hljs-keyword">RETURN</span> [n <span class="hljs-keyword">in</span> nodes(p) <span class="hljs-operator">|</span> n.name] <span class="hljs-keyword">AS</span> pairs, type(r) <span class="hljs-keyword">AS</span> results</span></pre><p name="6305" id="6305" class="graf graf--p graf-after--pre">Using only the <strong class="markup--strong markup--p-strong">&amp;</strong> expression does not really make sense as a single relationship cannot have more than one type. However, the combined with the negation <strong class="markup--strong markup--p-strong">!</strong> expression the <strong class="markup--strong markup--p-strong">&amp;</strong> can come in handy.</p><p name="d0c8" id="d0c8" class="graf graf--p graf-after--p">For example, the following Cypher statement expands all relationships that are not <strong class="markup--strong markup--p-strong">ALLIES</strong> or <strong class="markup--strong markup--p-strong">FAMILY</strong>.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="f470" id="f470" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">MATCH</span> p<span class="hljs-operator">=</span>(c:<span class="hljs-type">Character</span> <span class="hljs-keyword">WHERE</span> c.Culture <span class="hljs-operator">=</span> &quot;Fremen&quot;)<span class="hljs-operator">-</span>[r:<span class="hljs-operator">!</span>ALLIES<span class="hljs-operator">&amp;</span><span class="hljs-operator">!</span>FAMILY]<span class="hljs-operator">-</span>()<br /><span class="hljs-keyword">RETURN</span> [n <span class="hljs-keyword">in</span> nodes(p) <span class="hljs-operator">|</span> n.name] <span class="hljs-keyword">AS</span> pairs, type(r) <span class="hljs-keyword">AS</span> results</span></pre><h4 name="c5b3" id="c5b3" class="graf graf--h4 graf-after--pre">Existential subqueries</h4><p name="6deb" id="6deb" class="graf graf--p graf-after--h4">Next, you will learn how the syntax for existential subqueries changed. An existential subquery can be used to find graph patterns that are part of a specified pattern.</p><figure name="5a06" id="5a06" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*wCAYF6Gh_RDcIBAOad74NQ.png" data-width="905" data-height="355" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*wCAYF6Gh_RDcIBAOad74NQ.png"><figcaption class="imageCaption">Syntax change for existential filters. Image by the author.</figcaption></figure><p name="a49f" id="a49f" class="graf graf--p graf-after--figure">In this example, the existential subquery is used to find <strong class="markup--strong markup--p-strong">Character</strong> nodes that have either incoming or outgoing <strong class="markup--strong markup--p-strong">FAMILY</strong> relationships. I am a fan of existential subqueries as they offer the flexibility to filter nodes based on any graph patterns without having to expand them in the MATCH clause and worry about query cardinality (number of rows). In Neo4j v5, you have to add the <strong class="markup--strong markup--p-strong">EXISTS</strong> clause and wrap the specified graph pattern used for filtering with curly brackets in order to execute existential subqueries.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="sql" name="544c" id="544c" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">MATCH</span> (c:<span class="hljs-type">Character</span>)<br /><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">exists</span> { (c)<span class="hljs-operator">-</span>[:FAMILY]<span class="hljs-operator">-</span>() }<br /><span class="hljs-keyword">RETURN</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> count</span></pre><p name="e0b1" id="e0b1" class="graf graf--p graf-after--pre">Additionally, you can now introduce new reference variables in the existential subqueries. For example, the following existential subquery filters <strong class="markup--strong markup--p-strong">Character</strong> nodes with a <strong class="markup--strong markup--p-strong">FAMILY</strong> relationship. However, only the patterns where the end node of the <strong class="markup--strong markup--p-strong">FAMILY</strong> relationship has both the <strong class="markup--strong markup--p-strong">ALLIES</strong> and the <strong class="markup--strong markup--p-strong">MARRIAGE</strong> relationship are considered.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="sql" name="b65b" id="b65b" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">MATCH</span> (c:<span class="hljs-type">Character</span>)<br /><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">exists</span> { (c)<span class="hljs-operator">-</span>[:FAMILY]<span class="hljs-operator">-</span>(t)<br />               <span class="hljs-keyword">WHERE</span> (t)<span class="hljs-operator">-</span>[:ALLIES]<span class="hljs-operator">-</span>() <span class="hljs-keyword">AND</span> (t)<span class="hljs-operator">-</span>[:MARRIAGE]<span class="hljs-operator">-</span>() }<br /><span class="hljs-keyword">RETURN</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> count</span></pre><p name="8b6d" id="8b6d" class="graf graf--p graf-after--pre">You may also see examples of a <strong class="markup--strong markup--p-strong">MATCH</strong> clause used within the existential subquery. Based on my experience, the <strong class="markup--strong markup--p-strong">MATCH</strong> clause is entirely optional. However, it might make the existential subquery syntax more readable and intuitive.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="sql" name="2159" id="2159" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">MATCH</span> (c:<span class="hljs-type">Character</span>)<br /><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">exists</span> { <span class="hljs-keyword">MATCH</span> (c)<span class="hljs-operator">-</span>[:FAMILY]<span class="hljs-operator">-</span>(t)<br />               <span class="hljs-keyword">WHERE</span> (t)<span class="hljs-operator">-</span>[:ALLIES]<span class="hljs-operator">-</span>() <span class="hljs-keyword">AND</span> (t)<span class="hljs-operator">-</span>[:MARRIAGE]<span class="hljs-operator">-</span>() }<br /><span class="hljs-keyword">RETURN</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> count</span></pre><p name="0278" id="0278" class="graf graf--p graf-after--pre">Check out the documentation for more <a href="https://neo4j.com/docs/cypher-manual/current/syntax/expressions/#existential-subqueries" data-href="https://neo4j.com/docs/cypher-manual/current/syntax/expressions/#existential-subqueries" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">examples of existential subqueries</a>.</p><h4 name="31f6" id="31f6" class="graf graf--h4 graf-after--p">Count subqueries</h4><p name="8471" id="8471" class="graf graf--p graf-after--h4">The last category of subqueries in this post is the so-called count subqueries. They are used to count the number of defined graph patterns. For example, I frequently used them in my previous blog posts to count the number of relationships a node has.</p><figure name="ac88" id="ac88" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*D3lp5Ks9X2CESQU3l8rUzQ.png" data-width="555" data-height="345" src="https://cdn-images-1.medium.com/max/800/1*D3lp5Ks9X2CESQU3l8rUzQ.png"><figcaption class="imageCaption">Syntax change for counting subqueries. Image by the author.</figcaption></figure><p name="3f06" id="3f06" class="graf graf--p graf-after--figure">Previously, you could wrap a graph pattern with the <strong class="markup--strong markup--p-strong">size()</strong> in order to count the number of particular patterns. It is a handy syntax to count graph patterns without affecting the cardinality of the main query. Additionally, it might outperform other approaches to counting the number of relationships. In Neo4j v5, you need to replace the <strong class="markup--strong markup--p-strong">size()</strong> operator with the <strong class="markup--strong markup--p-strong">count{}</strong>.</p><p name="7121" id="7121" class="graf graf--p graf-after--p">The following Cypher statement returns the top five Character node ordered by their degree (relationship count).</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="javascript" name="3155" id="3155" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-variable constant_">MATCH</span> (<span class="hljs-attr">c</span>:<span class="hljs-title class_">Character</span>)<br /><span class="hljs-variable constant_">RETURN</span> c.<span class="hljs-property">name</span> <span class="hljs-variable constant_">AS</span> character,<br />       count{ (c)--() } <span class="hljs-variable constant_">AS</span> degree<br /><span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> degree <span class="hljs-variable constant_">DESC</span><br /><span class="hljs-variable constant_">LIMIT</span> <span class="hljs-number">5</span></span></pre><p name="2eba" id="2eba" class="graf graf--p graf-after--pre">As before, you can filter nodes by using the counting subqueries in a <strong class="markup--strong markup--p-strong">WHERE</strong> clause. In this example, the Cypher statement filters nodes with more than relationships.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="javascript" name="ed25" id="ed25" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-variable constant_">MATCH</span> (<span class="hljs-attr">c</span>:<span class="hljs-title class_">Character</span>)<br /><span class="hljs-variable constant_">WHERE</span> count{ (c)--() } &gt; <span class="hljs-number">2</span><br /><span class="hljs-variable constant_">RETURN</span> <span class="hljs-title function_">count</span>(*) <span class="hljs-variable constant_">AS</span> count</span></pre><h4 name="88d2" id="88d2" class="graf graf--h4 graf-after--pre">Summary</h4><p name="f297" id="f297" class="graf graf--p graf-after--h4">The new version of Neo4j offers faster performance and more Cypher flexibility. However, you might have to refactor a few of your existing Cypher statements to work with Neo4j v5. Hopefully, this blog post will help you with the upgrade process.</p><p name="0161" id="0161" class="graf graf--p graf-after--p graf--trailing">As always, the code is available on <a href="https://github.com/tomasonjo/blogs/blob/master/dune/Cypher_v5.ipynb" data-href="https://github.com/tomasonjo/blogs/blob/master/dune/Cypher_v5.ipynb" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">GitHub</a>.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@bratanic-tomaz" class="p-author h-card">Tomaz Bratanic</a> on <a href="https://medium.com/p/d0f10cbb60bf"><time class="dt-published" datetime="2023-01-17T14:18:01.888Z">January 17, 2023</time></a>.</p><p><a href="https://medium.com/@bratanic-tomaz/how-cypher-changed-in-neo4j-v5-d0f10cbb60bf" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on November 5, 2023.</p></footer></article></body></html>