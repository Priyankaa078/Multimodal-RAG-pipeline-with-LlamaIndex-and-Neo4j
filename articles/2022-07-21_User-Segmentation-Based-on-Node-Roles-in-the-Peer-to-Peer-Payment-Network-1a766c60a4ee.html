<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>User Segmentation Based on Node Roles in the Peer-to-Peer Payment Network</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">User Segmentation Based on Node Roles in the Peer-to-Peer Payment Network</h1>
</header>
<section data-field="subtitle" class="p-summary">
Utilize the Neo4j Graph Data Science library to identify node roles and use them as features for the user segmentation process
</section>
<section data-field="body" class="e-content">
<section name="e73f" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="4563" id="4563" class="graf graf--h3 graf--leading graf--title">User Segmentation Based on Node Roles in the Peer-to-Peer Payment Network</h3><h4 name="4139" id="4139" class="graf graf--h4 graf-after--h3 graf--subtitle">Utilize the Neo4j Graph Data Science library to identify node roles and use them as features for the user segmentation process</h4><p name="8c2f" id="8c2f" class="graf graf--p graf-after--h4">Knowing your users is vital to any business. When your users can interact with each other on a social media platform, content sharing platform, or even work-related platforms, you can construct a network between your users based on their interactions and extract graph-based features to segment your users. Of course, these same approaches can be applied to other platforms that are not user-centric.</p><p name="a8fb" id="a8fb" class="graf graf--p graf-after--p">In this blog post, I will walk you through the user segmentation process of a peer-to-peer payment platform through network analysis.</p><p name="459a" id="459a" class="graf graf--p graf-after--p">On a peer-to-peer platform, users can digitally transfer money online to anyone else on the platform. Such platforms have gained a lot of popularity in recent years. Examples of real-world peer-to-peer payment platforms are Venmo, PayPal, and Revolut.</p><figure name="85fc" id="85fc" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*tf7cvPaL1WNL188ZiE4lRw.png" data-width="671" data-height="368" src="https://cdn-images-1.medium.com/max/800/1*tf7cvPaL1WNL188ZiE4lRw.png"><figcaption class="imageCaption">Peer-to-peer payment network. Image by the author.</figcaption></figure><p name="7110" id="7110" class="graf graf--p graf-after--figure">We can represent the transactions between users as a network where nodes represent users, and the relationships represent transactions. The connections have a weight or a property that contains the information about the total amount sent. If your dataset includes the timeline information, you could also add the dates of transactions to the relationships.</p><p name="f847" id="f847" class="graf graf--p graf-after--p">In order to segment the users in the network, we need to come up with features that describe the role of users in the network. In general, we could take advantage of running unsupervised algorithms that auto-magically encode node positions and roles in the network as a vector per node.</p><p name="6724" id="6724" class="graf graf--p graf-after--p">However, the problem with the unsupervised approach to feature engineering is that it’s <em class="markup--em markup--p-em">hard to explain the results</em>. For this reason, we will manually construct feature vectors for users.</p><p name="c880" id="c880" class="graf graf--p graf-after--p">We can encode anything in the feature vectors we deem descriptive of user roles in the network. For example, in a peer-to-peer payment network, it makes sense to <em class="markup--em markup--p-em">encode how many transactions and their values a user has</em> but also look at <em class="markup--em markup--p-em">which users connect to different communities</em> and act as a bridge between them.</p><p name="3131" id="3131" class="graf graf--p graf-after--p">In this example, we will combine some simple statistics like the <em class="markup--em markup--p-em">average transaction value</em> of a user with outputs of graph algorithms like the <em class="markup--em markup--p-em">Betweenness Centrality</em> to encode the user roles in the network.</p><figure name="5967" id="5967" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*FZ-ErOqN9NLJ1hQuez8p1Q.png" data-width="966" data-height="519" src="https://cdn-images-1.medium.com/max/800/1*FZ-ErOqN9NLJ1hQuez8p1Q.png"><figcaption class="imageCaption">User segmentation process. Image by the author.</figcaption></figure><p name="999c" id="999c" class="graf graf--p graf-after--figure">As mentioned, we need to encode user roles and positions in the network as vectors. In this post, we will manually construct features describing nodes. These features are:</p><ul class="postList"><li name="59ac" id="59ac" class="graf graf--li graf-after--p">Average transaction amount</li><li name="e1d4" id="e1d4" class="graf graf--li graf-after--li">Years since first transaction</li><li name="6eb1" id="6eb1" class="graf graf--li graf-after--li">Weighted in-degree (total amount received)</li><li name="cdc0" id="cdc0" class="graf graf--li graf-after--li">Weighted out-degree (total amount sent)</li><li name="d154" id="d154" class="graf graf--li graf-after--li">Betweenness centrality</li><li name="f706" id="f706" class="graf graf--li graf-after--li">Closeness centrality</li></ul><p name="a8a7" id="a8a7" class="graf graf--p graf-after--li">We will use these six features to encode node roles and positions in the network. The average transaction amount and the years since the first transaction features are used to capture how old they accounts are and how much on average they send. Next, we will use the weighted in and out-degrees to encode the total amount sent and received by the user. Lastly, we will use the Closeness and Betweenness centralities algorithms to encode the node position in the network.</p><p name="a1cc" id="a1cc" class="graf graf--p graf-after--p">After the feature engineering process is completed, we will use the <a href="https://en.wikipedia.org/wiki/K-means_clustering" data-href="https://en.wikipedia.org/wiki/K-means_clustering" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">K-means</a> algorithm to cluster the data points into groups or communities of users. These communities will represent various segments of users on the platform.</p><h4 name="51d6" id="51d6" class="graf graf--h4 graf-after--p">Environment setup</h4><p name="bf7d" id="bf7d" class="graf graf--p graf-after--h4">We will be using <a href="https://neo4j.com/" data-href="https://neo4j.com/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Neo4j</a> as the database to store the peer-to-peer network. Therefore, I suggest you download and install the <a href="https://neo4j.com/download/" data-href="https://neo4j.com/download/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Neo4j Desktop application</a> if you want to follow along with the code examples.</p><p name="a4c5" id="a4c5" class="graf graf--p graf-after--p">The dataset is available as a <a href="https://drive.google.com/file/d/1_N_QLtCRI-eeLzjEIFZAbj8YQrWfTolI/view" data-href="https://drive.google.com/file/d/1_N_QLtCRI-eeLzjEIFZAbj8YQrWfTolI/view" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">database dump</a>. It is a variation of the database dump available on Neo4j’s <a href="https://github.com/neo4j-product-examples/demo-fraud-detection-with-p2p" data-href="https://github.com/neo4j-product-examples/demo-fraud-detection-with-p2p" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">product example GitHub to showcase fraud detection</a>.</p><div name="0106" id="0106" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://drive.google.com/file/d/1_N_QLtCRI-eeLzjEIFZAbj8YQrWfTolI/view" data-href="https://drive.google.com/file/d/1_N_QLtCRI-eeLzjEIFZAbj8YQrWfTolI/view" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://drive.google.com/file/d/1_N_QLtCRI-eeLzjEIFZAbj8YQrWfTolI/view"><strong class="markup--strong markup--mixtapeEmbed-strong">fraud-neo4j-v44.dump</strong><br><em class="markup--em markup--mixtapeEmbed-em">Edit description</em>drive.google.com</a><a href="https://drive.google.com/file/d/1_N_QLtCRI-eeLzjEIFZAbj8YQrWfTolI/view" class="js-mixtapeImage mixtapeImage mixtapeImage--empty u-ignoreBlock" data-media-id="5fa289b7e426e7b080e3f5b5c6b5031e"></a></div><p name="83dc" id="83dc" class="graf graf--p graf-after--mixtapeEmbed">I wrote a post about <a href="https://tbgraph.wordpress.com/2020/11/11/dump-and-load-a-database-in-neo4j-desktop/" data-href="https://tbgraph.wordpress.com/2020/11/11/dump-and-load-a-database-in-neo4j-desktop/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">restoring a database dump in Neo4j Desktop</a> a while back if you need some help. After you have restored the database dump, you will also need to install the <a href="https://neo4j.com/docs/graph-data-science/current/" data-href="https://neo4j.com/docs/graph-data-science/current/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Graph Data Science</a> and <a href="https://neo4j.com/labs/apoc/" data-href="https://neo4j.com/labs/apoc/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">APOC</a> libraries. Make sure you are using version 2.1.0 of the GDS library or later.</p><p name="4dd0" id="4dd0" class="graf graf--p graf-after--p">The code with the examples in this post is available on <a href="https://github.com/tomasonjo/blogs/blob/master/gds_python/p2p-network-analysis.ipynb" data-href="https://github.com/tomasonjo/blogs/blob/master/gds_python/p2p-network-analysis.ipynb" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">GitHub</a>.</p><div name="c35a" id="c35a" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://github.com/tomasonjo/blogs/blob/master/gds_python/p2p-network-analysis.ipynb" data-href="https://github.com/tomasonjo/blogs/blob/master/gds_python/p2p-network-analysis.ipynb" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://github.com/tomasonjo/blogs/blob/master/gds_python/p2p-network-analysis.ipynb"><strong class="markup--strong markup--mixtapeEmbed-strong">blogs/p2p-network-analysis.ipynb at master · tomasonjo/blogs</strong><br><em class="markup--em markup--mixtapeEmbed-em">Jupyter notebooks that support my graph data science blog posts at https://bratanic-tomaz.medium.com/ …</em>github.com</a><a href="https://github.com/tomasonjo/blogs/blob/master/gds_python/p2p-network-analysis.ipynb" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="5f199904f39fbad7610ad1518c4cea7f" data-thumbnail-img-id="0*MYqW_YeGdw0jxiOf" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*MYqW_YeGdw0jxiOf);"></a></div><p name="02cd" id="02cd" class="graf graf--p graf-after--mixtapeEmbed">You will need to have the following three Python libraries installed:</p><ul class="postList"><li name="168a" id="168a" class="graf graf--li graf-after--p">graphdatascience: Neo4j Graph Data Science Python client</li><li name="8986" id="8986" class="graf graf--li graf-after--li">seaborn: Visualization library</li><li name="2167" id="2167" class="graf graf--li graf-after--li">scikit-learn: We will use t-SNE dimensionality reduction</li></ul><h4 name="bfcb" id="bfcb" class="graf graf--h4 graf-after--li">Setting up the connection to Neo4j</h4><p name="3a61" id="3a61" class="graf graf--p graf-after--h4">Now we are ready to start coding. First, we need to define the connections to the Neo4j instance with the <code class="markup--code markup--p-code">graphdatascience</code> library.</p><figure name="da31" id="da31" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tomasonjo/a2659651eaf8bedc4b644f8a2a603280.js"></script></figure><p name="a1f4" id="a1f4" class="graf graf--p graf-after--figure">We need to fill in the credentials to define the connection to the Neo4j instance. Make sure to change the <code class="markup--code markup--p-code">password</code>variable to the appropriate value. I like to print the <code class="markup--code markup--p-code">gds.version()</code> method to make sure that the connection is valid and the target database has the Graph Data Science library installed.</p><p name="f85d" id="f85d" class="graf graf--p graf-after--p">We can quickly evaluate the populated graph schema with the <code class="markup--code markup--p-code">apoc.meta.stats</code> procedure.</p><figure name="d10e" id="d10e" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tomasonjo/6cc7e6b05927ba6fe3274489790fa6d2.js"></script></figure><p name="4416" id="4416" class="graf graf--p graf-after--figure">There are 33,732 users in the database and 102,832 P2P transactions. There could be multiple P2P transactions between a pair of users. Therefore, we are dealing with a directed weighted multigraph. We have some additional information about the users available, such as which IPs, credit cards, and devices they have used.</p><h4 name="0f2b" id="0f2b" class="graf graf--h4 graf-after--p">Feature engineering</h4><p name="9819" id="9819" class="graf graf--p graf-after--h4">We will now move on to calculating user features used for segmentation. The first two features we will extract are the account age, calculated by looking at the first transaction, and the average transaction amount. We will use a single Cypher statement to calculate them and store them as node properties in the database.</p><p name="892e" id="892e" class="graf graf--p graf-after--p">The <code class="markup--code markup--p-code">gds</code>object has a <code class="markup--code markup--p-code">run_cypher</code>method that allows you to execute any Cypher statements.</p><figure name="13a8" id="13a8" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tomasonjo/eb848964f12d2ae7a6175f112d4d0382.js"></script></figure><p name="c03f" id="c03f" class="graf graf--p graf-after--figure">The remaining four attributes will be calculated by executing graph algorithms available in the Graph Data Science library. The <code class="markup--code markup--p-code">graphdatascience</code> library allows you to execute any GDS procedure and algorithm using pure Python code. I wrote an <a href="https://neo4j.com/developer-blog/get-started-with-neo4j-gds-python-client/" data-href="https://neo4j.com/developer-blog/get-started-with-neo4j-gds-python-client/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">article on mapping GDS syntax from Cypher statements to pure Python code</a> to help you with the transition.</p><p name="7d9e" id="7d9e" class="graf graf--p graf-after--p">First, we need to project an in-memory graph. The projected graph schema will be relatively simple and will contain only <code class="markup--code markup--p-code">User</code> nodes and <code class="markup--code markup--p-code">P2P</code> relationships. In addition, we will include node properties <code class="markup--code markup--p-code">accountYears</code> and <code class="markup--code markup--p-code">avgTransactionAmount</code> and relationship property <code class="markup--code markup--p-code">totalAmount</code> in the projection.</p><figure name="8a78" id="8a78" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tomasonjo/689805345114a493254d7fd97cbd3cd3.js"></script></figure><p name="4d00" id="4d00" class="graf graf--p graf-after--figure">Since we want to use network features like the Betweenness and Closeness centrality for user segmentation, we will first evaluate how connected our network is using the Weakly Connected Components algorithm. The Weakly Connected Components algorithm is used to find disconnected parts or islands in the network and can help you evaluate how connected the network is overall.</p><p name="0772" id="0772" class="graf graf--p graf-after--p">We will use the <code class="markup--code markup--p-code">mutate</code>mode of the Weakly Connected Components algorithm, which stores the results to the projected graph and returns high-level statistics of the algorithm result.</p><figure name="ae7f" id="ae7f" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tomasonjo/a47ffd7b5914d8d90db1ceb0cec1ea99.js"></script></figure><p name="55ad" id="55ad" class="graf graf--p graf-after--figure">There are 7743 disconnected components in our P2P network. That is a high and slightly unexpected amount of disconnected components, as there are only around 30,000 users in the network. The largest component has 11,311 members, about 30 percent of the population, while other components are tiny and contain only a few members. We notice that 99 percent of communities have 12 or fewer members.</p><p name="ae1f" id="ae1f" class="graf graf--p graf-after--p">Since we want to segment our users based on their network features, we will focus our analysis on the largest component only and ignore the rest. This is because the network attributes are not very descriptive when dealing with small components that contain five members. More importantly, I want to show you how to filter the largest component in your projected graph. However, you could always run your analysis on the whole network if you wanted to, or if that was the requirement.</p><p name="5cb0" id="5cb0" class="graf graf--p graf-after--p">The subgraph filter projection procedure allows us to filter projected graphs on mutated properties. In this example, we will select only nodes that are part of the largest component. Then, the subgraph filter projection creates a new graph based on the specified predicates.</p><figure name="3d00" id="3d00" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tomasonjo/a32ffb0359ec6556066c5df2a9860aae.js"></script></figure><p name="f995" id="f995" class="graf graf--p graf-after--figure">First, we needed to fetch the id of the largest component. We can retrieve mutated properties from the projected graph using the <code class="markup--code markup--p-code">gds.graph.streamNodeProperty</code> method. Next, we applied a simple aggregation and sorting to extract the particular component id, and then used it as an input to the subgraph filter projection method.</p><p name="2ec3" id="2ec3" class="graf graf--p graf-after--p">Now that we have the projected graph containing only the largest component ready, we can extract the network features. We will begin by calculating the weighted in and out-degrees. Again, we will use the <code class="markup--code markup--p-code">mutate</code>mode of the algorithm to store the results back to the projected graph.</p><figure name="14aa" id="14aa" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tomasonjo/08c29d0c5b130c97e28e7fe15aa5868e.js"></script></figure><p name="01a1" id="01a1" class="graf graf--p graf-after--figure">The only two features we need to calculate are the Betweenness and Closeness centralities. The Betweenness centrality is used to find bridges in the network connecting different community nodes.</p><figure name="97d9" id="97d9" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*8q7eLKVRBkcJx_2FU7oreA.png" data-width="616" data-height="431" src="https://cdn-images-1.medium.com/max/800/1*8q7eLKVRBkcJx_2FU7oreA.png"><figcaption class="imageCaption">Sample network where nodes are colored based on the Betweenness centrality from white (smaller score) to red (higher score). Image by the author.</figcaption></figure><p name="b02e" id="b02e" class="graf graf--p graf-after--figure">This example visualized a Marvel network, where relationships represent which characters appeared together in a comic. A prime example of Betweenness centrality is the character Beast, which connects the right-hand-side community with the other part of the network. If he was removed from the network, there would be no connection between the two communities. We can say that character Beast acts as a bridge between the two communities.</p><p name="0380" id="0380" class="graf graf--p graf-after--p">Closeness centrality is a way to identify nodes close to all the other nodes in the network and can therefore spread the information to the network efficiently. The idea is that the information only spreads through the shortest paths between pairs of nodes.</p><figure name="3f8d" id="3f8d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*9BnGDxOU9fNOd4NUFBrvsw.png" data-width="616" data-height="431" src="https://cdn-images-1.medium.com/max/800/1*9BnGDxOU9fNOd4NUFBrvsw.png"><figcaption class="imageCaption">Sample network where nodes are colored based on the Closeness centrality from white (smaller score) to red (higher score). Image by the author.</figcaption></figure><p name="ff0f" id="ff0f" class="graf graf--p graf-after--figure">We can observe that nodes in the center of the network have the highest Closeness centrality score as they are able to reach all the other nodes the fastest.</p><p name="94ae" id="94ae" class="graf graf--p graf-after--p">We calculate the Closeness and Betweenness centrality score with the following code:</p><figure name="c0b5" id="c0b5" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tomasonjo/ef3168eacfc61721ad0c8b4bf171411b.js"></script></figure><h4 name="916e" id="916e" class="graf graf--h4 graf-after--figure">Feature exploration</h4><p name="8a68" id="8a68" class="graf graf--p graf-after--h4">Before we move on to the K-means clustering part, we will quickly evaluate the distributions of our features. We can fetch multiple mutated properties from the projected graph using the <code class="markup--code markup--p-code">gds.graph.streamNodeProperties</code>method.</p><figure name="cdee" id="cdee" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tomasonjo/777c509d1dcbbe90d727b6ec1b4432d2.js"></script></figure><p name="41d7" id="41d7" class="graf graf--p graf-after--figure">The <code class="markup--code markup--p-code">features_df</code> dataframe has the following structure:</p><figure name="2221" id="2221" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*i-n8ZqGgf6STA2-4mSZarw.png" data-width="303" data-height="167" src="https://cdn-images-1.medium.com/max/800/1*i-n8ZqGgf6STA2-4mSZarw.png"><figcaption class="imageCaption">Structure of the features_df dataframe. Image by the author.</figcaption></figure><p name="b6eb" id="b6eb" class="graf graf--p graf-after--figure">We can use the <code class="markup--code markup--p-code">features_df</code> dataframe to visualize the distributions of our features.</p><figure name="2e4a" id="2e4a" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tomasonjo/d7a042afb8d860a1b2dd3561c533c252.js"></script></figure><figure name="4c29" id="4c29" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*A5JJs9gjhEuEZmVNZ0F0YQ.png" data-width="979" data-height="650" src="https://cdn-images-1.medium.com/max/800/1*A5JJs9gjhEuEZmVNZ0F0YQ.png"><figcaption class="imageCaption">Distributions of the features. Image by the author.</figcaption></figure><p name="41b5" id="41b5" class="graf graf--p graf-after--figure">Interestingly, the account age is equally distributed through the years. Most users have a small average transaction amount of only a few hundred. However, some outliers have an average transaction amount of more than 3000. We have a few outliers in the weighted out-degree that have sent values of over half a million. The dataset doesn’t contain the currency, so I can’t say if we are dealing with USD or not.</p><p name="313d" id="313d" class="graf graf--p graf-after--p">The <code class="markup--code markup--p-code">gds.graph.streamNodeProperties</code>has a special keyword <strong class="markup--strong markup--p-strong">separate_property_columns</strong> attribute that pivots the dataframe automatically for us. Let’s try it out.</p><figure name="6c69" id="6c69" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tomasonjo/284d6e2a73a9cb4ffad8d34058a3382f.js"></script></figure><p name="ff57" id="ff57" class="graf graf--p graf-after--figure">The <code class="markup--code markup--p-code">pivot_features_df</code>dataframe has the following structure:</p><figure name="fcf6" id="fcf6" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*PG7raiigLwJiiJiqnpg8OA.png" data-width="783" data-height="166" src="https://cdn-images-1.medium.com/max/800/1*PG7raiigLwJiiJiqnpg8OA.png"><figcaption class="imageCaption">Structure of the pivot_features_df dataframe. Image by the author.</figcaption></figure><p name="0546" id="0546" class="graf graf--p graf-after--figure">If you are not that visually oriented and want to get a table of distribution statistics, you can use the <code class="markup--code markup--p-code">describe</code> method of the dataframe.</p><figure name="39df" id="39df" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tomasonjo/661b2e203afd7dc353c5a266cdf93988.js"></script></figure><p name="703a" id="703a" class="graf graf--p graf-after--figure"><em class="markup--em markup--p-em">Results</em></p><figure name="94f6" id="94f6" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*54n5cWfRhuniP6XgWF5Y4w.png" data-width="840" data-height="240" src="https://cdn-images-1.medium.com/max/800/1*54n5cWfRhuniP6XgWF5Y4w.png"><figcaption class="imageCaption">Results of the describe method. Image by the author.</figcaption></figure><p name="2dbe" id="2dbe" class="graf graf--p graf-after--figure">The pivot dataframe structure is also handy when we want to visualize the correlation matrix.</p><figure name="6fbe" id="6fbe" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tomasonjo/8181bd68151bf80e868ff10eba7e1422.js"></script></figure><p name="1d16" id="1d16" class="graf graf--p graf-after--figure"><em class="markup--em markup--p-em">Results</em></p><figure name="c532" id="c532" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*WS1DkqY2a4eannzFxNp_MQ.png" data-width="966" data-height="372" src="https://cdn-images-1.medium.com/max/800/1*WS1DkqY2a4eannzFxNp_MQ.png"><figcaption class="imageCaption">Correlation matrix. Image by the author.</figcaption></figure><p name="1c42" id="1c42" class="graf graf--p graf-after--figure">We can observe that the Betweenness centrality correlates with both the weighted in and out-degrees. Other than that, it seems that our features are not that correlated.</p><h4 name="d831" id="d831" class="graf graf--h4 graf-after--p">K-means clustering</h4><p name="a97a" id="a97a" class="graf graf--p graf-after--h4">K-means clustering is a widely used technique to group or cluster data points. However, since there are no training labels to learn from, the K-means algorithm is regarded as an unsupervised machine learning algorithm. The algorithm starts with the first group of randomly selected centroids used as baseline points for every cluster. The number of clusters is a fixed number defined with the parameter k. The algorithm then assigns each data point to the nearest centroid and iteratively optimizes the position of centroids.</p><p name="10ab" id="10ab" class="graf graf--p graf-after--p">There are plenty of great resources on the web about the K-means algorithm, so I won’t go into detail about how it works.</p><p name="98a1" id="98a1" class="graf graf--p graf-after--p">But there’s one crucial component to understand how it differs from other community detection algorithms like the Louvain or Label Propagation algorithms. Instead of using a graph of nodes and relationships as an input, we need to input vectors (array of numbers) of features that describe each data point.</p><p name="f09c" id="f09c" class="graf graf--p graf-after--p">Before running the K-means algorithm, we need to standardize our features, so that some features with high values will not skew the results. Therefore, we will use the <a href="https://en.wikipedia.org/wiki/Standard_score#:~:text=In%20statistics%2C%20the%20standard%20score,is%20being%20observed%20or%20measured." data-href="https://en.wikipedia.org/wiki/Standard_score#:~:text=In%20statistics%2C%20the%20standard%20score,is%20being%20observed%20or%20measured." class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">standard score scaler</a>, which is available in the Graph Data Science library.</p><figure name="7a46" id="7a46" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tomasonjo/ca36958d65b90749009e966c2b1dea97.js"></script></figure><p name="239d" id="239d" class="graf graf--p graf-after--figure">We have selected our six features to be scaled and mutated under the <code class="markup--code markup--p-code">features</code> node property in the projected graph. The <code class="markup--code markup--p-code">features</code> node property type is a vector or an array of numbers.</p><p name="34fb" id="34fb" class="graf graf--p graf-after--p">The only thing left to do is execute the -means algorithm. We need to define how many clusters we want to identify by specifying the parameter <code class="markup--code markup--p-code">k</code>. For the purpose of blog presentability, I will use a smaller value of 6. However, you should probably use a larger number when you don’t need to sacrifice accuracy for blog presentability like me.</p><figure name="abb3" id="abb3" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tomasonjo/91fd2e2f2e0e27b2c801f9f519d7e40a.js"></script></figure><h4 name="36fe" id="36fe" class="graf graf--h4 graf-after--figure">Inspect cluster results</h4><p name="e257" id="e257" class="graf graf--p graf-after--h4">We will begin the cluster analysis by evaluating the size of clusters. First, we need to merge the <code class="markup--code markup--p-code">kmeans_df</code> dataframe with the <code class="markup--code markup--p-code">pivot_features_df</code>. Next, we use a simple group by aggregation to calculate the size of clusters.</p><figure name="55d9" id="55d9" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tomasonjo/b084db3ea8a2d09691dd80e7296503c4.js"></script></figure><p name="a119" id="a119" class="graf graf--p graf-after--figure"><em class="markup--em markup--p-em">Results</em></p><figure name="5484" id="5484" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*R7oDTTVxWzaPrm1ps_Mk7g.png" data-width="217" data-height="187" src="https://cdn-images-1.medium.com/max/800/1*R7oDTTVxWzaPrm1ps_Mk7g.png"><figcaption class="imageCaption">Cluster size results. Image by the author.</figcaption></figure><p name="232b" id="232b" class="graf graf--p graf-after--figure">The cluster sizes vary from 217 members all the way to 4870 members. While we could calculate statistics of features for every community, it is tough to compress the results and make them presentable in a blog. Therefore, we will first evaluate the weighted out-degree (total amount sent to other users) per cluster.</p><figure name="96f8" id="96f8" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tomasonjo/0d9abc5b5ae4f9f0e6d45c0908db29ba.js"></script></figure><p name="6c57" id="6c57" class="graf graf--p graf-after--figure"><em class="markup--em markup--p-em">Results</em></p><figure name="71a7" id="71a7" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*9oI7HbbjHj_Hrz6f_PWFAQ.png" data-width="976" data-height="642" src="https://cdn-images-1.medium.com/max/800/1*9oI7HbbjHj_Hrz6f_PWFAQ.png"><figcaption class="imageCaption">Distribution of weighted out-degree per cluster. Image by the author.</figcaption></figure><p name="f5cf" id="f5cf" class="graf graf--p graf-after--figure">Users in communities 3 and 5 have no outgoing transactions, as their total amount sent to other users is zero. Communities 1 and 2 represent users that sent a small amount to other users. On the other hand, the community with id 4 represents power users who sent vast amounts to other users.</p><p name="d007" id="d007" class="graf graf--p graf-after--p">Let’s say we are interested in learning more about the power users community. We can use Pandas methods to filter and transform the data to an appropriate structure to be visualized with the Seaborn library.</p><figure name="ec3f" id="ec3f" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tomasonjo/cc28034e7bebc5d74d44ee7200500328.js"></script></figure><p name="1845" id="1845" class="graf graf--p graf-after--figure"><em class="markup--em markup--p-em">Results</em></p><figure name="6f2c" id="6f2c" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*fAB-LJRiAkDJ8sEtHLqz0w.png" data-width="971" data-height="636" src="https://cdn-images-1.medium.com/max/800/1*fAB-LJRiAkDJ8sEtHLqz0w.png"><figcaption class="imageCaption">Feature statistics of power user community. Image by the author.</figcaption></figure><p name="3ea8" id="3ea8" class="graf graf--p graf-after--figure">It seems that power users are more or less the oldest accounts. Their average transaction amount usually ranges between 500 to 2500. So they sent a lot of currency to other users, but also received a lot of it. Not surprisingly, they have, on average, a high Betweenness score. Therefore, we can assume that they connect various communities of users and act as a bridge between them.</p><p name="04ae" id="04ae" class="graf graf--p graf-after--p">Lastly, we will plot the clusters on a scatter plot. In order to achieve this, we need to use a dimensionality reduction algorithm like t-SNE to reduce the feature dimensionality to 2.</p><figure name="3f7d" id="3f7d" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/tomasonjo/df50a40dd921ccc94a74c0d65e5f29fa.js"></script></figure><p name="b11e" id="b11e" class="graf graf--p graf-after--figure"><em class="markup--em markup--p-em">Results</em></p><figure name="3bb4" id="3bb4" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*YSynbpnKVFMEMJDl7IBi2w.png" data-width="979" data-height="539" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*YSynbpnKVFMEMJDl7IBi2w.png"><figcaption class="imageCaption">Scatter plot visualization of identified clusters. Image by the author.</figcaption></figure><p name="e761" id="e761" class="graf graf--p graf-after--figure">Maybe it is evident from this visualization that our cluster analysis accuracy would benefit from raising the number of clusters by increasing the K value. You may also be asking yourself why the split between clusters isn’t more distinct. For example, the red community is present on both the left and right sides of the visualization. I attribute this to the t-SNE dimensionality reduction algorithm. If we were to run the K-means algorithm on only two features, we should get a nice distinct split between clusters.</p><h4 name="d6ef" id="d6ef" class="graf graf--h4 graf-after--p">Conclusion</h4><p name="3344" id="3344" class="graf graf--p graf-after--h4">K-means algorithm was added to the Neo4j Graph Data Science library just recently and is a wonderful addition that can be used in your data science workflows. I also enjoy the new Neo4j Graph Data Science Python client that seamlessly integrates with other Python data science libraries.</p><p name="93ba" id="93ba" class="graf graf--p graf-after--p">It gives me an excuse to brush up on my visualization skills to make excellent presentations or explore outputs visually. I will definitely be using it in my projects. I encourage you to try it out and learn about its benefits.</p><p name="9264" id="9264" class="graf graf--p graf-after--p graf--trailing">As always, the code is available on <a href="https://github.com/tomasonjo/blogs/blob/master/gds_python/p2p-network-analysis.ipynb" data-href="https://github.com/tomasonjo/blogs/blob/master/gds_python/p2p-network-analysis.ipynb" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">GitHub</a>.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@bratanic-tomaz" class="p-author h-card">Tomaz Bratanic</a> on <a href="https://medium.com/p/1a766c60a4ee"><time class="dt-published" datetime="2022-07-21T21:44:43.475Z">July 21, 2022</time></a>.</p><p><a href="https://medium.com/@bratanic-tomaz/user-segmentation-based-on-node-roles-in-the-peer-to-peer-payment-network-1a766c60a4ee" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on November 5, 2023.</p></footer></article></body></html>